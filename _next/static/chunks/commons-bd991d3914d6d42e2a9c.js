(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[351],{6086:function(t){"use strict";var e=Object.assign.bind(Object);t.exports=e,t.exports.default=t.exports},4360:function(t){t.exports=function(t,e){(null==e||e>t.length)&&(e=t.length);for(var a=0,n=new Array(e);a<e;a++)n[a]=t[a];return n}},2553:function(t){t.exports=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}},2012:function(t){function e(t,e){for(var a=0;a<e.length;a++){var n=e[a];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}t.exports=function(t,a,n){return a&&e(t.prototype,a),n&&e(t,n),t}},2426:function(t){t.exports=function(t){return t&&t.__esModule?t:{default:t}}},1914:function(t){function e(a,n){return t.exports=e=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},e(a,n)}t.exports=e},7917:function(t){function e(a){return"function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?t.exports=e=function(t){return typeof t}:t.exports=e=function(t){return t&&"function"===typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},e(a)}t.exports=e},3585:function(t,e,a){var n=a(4360);t.exports=function(t,e){if(t){if("string"===typeof t)return n(t,e);var a=Object.prototype.toString.call(t).slice(8,-1);return"Object"===a&&t.constructor&&(a=t.constructor.name),"Map"===a||"Set"===a?Array.from(t):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?n(t,e):void 0}}},6243:function(t,e,a){"use strict";a.d(e,{z_:function(){return O},es:function(){return F},OX:function(){return R},U8:function(){return z},t4:function(){return H},dH:function(){return D},UN:function(){return $},qX:function(){return B},se:function(){return j},my:function(){return J},DU:function(){return tt},SI:function(){return Q},My:function(){return et},T4:function(){return nt},pj:function(){return it},mU:function(){return rt},Ig:function(){return ot},DV:function(){return dt},KX:function(){return yt},z$:function(){return vt},c7:function(){return St},KO:function(){return mt},qs:function(){return bt},Lb:function(){return Tt},he:function(){return Et},Lj:function(){return _t},Te:function(){return q},lw:function(){return Z},Gq:function(){return Ct},lE:function(){return It},j_:function(){return Ft},AP:function(){return Gt},gm:function(){return $t},sh:function(){return Bt},Eg:function(){return Xt},lu:function(){return Vt},hi:function(){return Lt},BV:function(){return Ot},IH:function(){return Rt},ZT:function(){return Mt},Bf:function(){return Kt},Mm:function(){return Pt},sc:function(){return Ut},He:function(){return U},OS:function(){return K},x1:function(){return Nt}});class n{static GlobalCountIncrease(){return n.GlobalNodesCount+=1,n.GlobalNodesCount}constructor(t){this.id=n.GlobalCountIncrease(),this.name=`${t}:${this.id}`}}n.GlobalNodesCount=0;class i{constructor(t,e,a,n){this.gl=t,this.name=a,this.dtype=n,this.location=t.getUniformLocation(e,this.name)}set(t){const e=this.gl;switch(this.dtype){case"int":e.uniform1i(this.location,t);break;case"float":e.uniform1f(this.location,t);break;case"vec2":e.uniform2fv(this.location,t);break;case"vec3":e.uniform3fv(this.location,t);break;case"vec4":e.uniform4fv(this.location,t);break;case"mat3":e.uniformMatrix3fv(this.location,!1,t);break;case"mat4":e.uniformMatrix4fv(this.location,!1,t);break;default:return!1}return!0}}class r{constructor(t,e,a,n){this.program=e,this.gl=t,this.name=a,this.dtype=n,this.location=t.getAttribLocation(this.program,this.name),this.ctx=t.createBuffer(),this.empty=new ArrayBuffer(1),"float"===n||"int"===n?this.size=1:(this.size=parseInt(/\d/g.exec(n)[0],10),t.enableVertexAttribArray(this.location))}set(t){const e=this.gl;this.bind(this.ctx),"int"===this.dtype?e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(t),e.STATIC_DRAW):e.bufferData(e.ARRAY_BUFFER,new Float32Array(t),e.STATIC_DRAW)}bind(){const t=this.gl;"int"===this.dtype?t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.ctx):(t.bindBuffer(t.ARRAY_BUFFER,this.ctx),t.vertexAttribPointer(this.location,this.size,t.FLOAT,!1,0,0))}unbind(){const t=this.gl;"int"===this.dtype?t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null):(t.bindBuffer(t.ARRAY_BUFFER,null),t.vertexAttribPointer(this.location,this.size,t.FLOAT,!1,0,0))}disable(){this.gl.disableVertexAttribArray(this.ctx)}enable(){this.gl.enableVertexAttribArray(this.ctx)}delete(){this.gl.deleteBuffer(this.ctx),this.program=null,this.gl=null,this.ctx=null}}const o="Error: An error occurred compiling the shaders: ";function s(t){const e=/\d+\|(\s+)/.exec(t);return" ".repeat(e?e[1].length:2)}function l(t){let e=t.split("\n");const a=(e.length+1).toString().length;return e=e.map(((t,e)=>`${(e+1).toString().padStart(a)}|  ${t}`)),e}function c(t,e,a){try{const n=function(t,e,a=!0){const n=l(t),i=(n.length+1).toString().length;let r=e.toString();const c=[],u=[];r.startsWith(o)&&(r=r.substr(o.length));const h=r.split("\n"),f=function(t){let e=0,a=0;for(let n=0;n<t.length;n+=1)/ERROR/.exec(t[n])&&(e+=1),/WARNING/.exec(t[n])&&(a+=1);return{errCount:e,warnCount:a}}(h);let d=0;for(let o=0;o<h.length;o+=1){const t=h[o],e=/0:(\d+)/.exec(t);if(e){const r=+e[1]+d,o=`${" ".repeat(i)}|${s(n[r-1])}`;c.push(`${t}\n${n[r-2]}\n${n[r-1]}\n${o}^\n${n[r]}`);const l=a?"%c":"";n.splice(r,0,`${l}${o}^--${t}${l}`),a&&(u.push("color: red;"),u.push("color: inherit;")),d+=1}}return{fullText:n.join("\n"),firstError:c[0],errorsStats:f,fullTextStyle:u}}(t,a),i=n.errorsStats;console.group(`Error: An error occurred compiling the shader ${e}: ${i.errCount} ERRORS, ${i.warnCount} WARNINGS`),console.log(n.firstError),console.groupCollapsed("Show more"),console.log(n.fullText,...n.fullTextStyle),console.groupEnd(),console.groupEnd()}catch(n){console.warn("Unable to process GLSG compiling error.")}}const u=["pickCurrentValue","pickValue","float"],h=(t,e)=>{if(!t)throw new Error(e)},f=(t,e)=>{h(t,`GammaCV: DOMFeature not supported, "${e}" is not supported in current environment`)},d=t=>{f(document&&document.createElement,t)},p=t=>Array.isArray(t)&&t.length>0&&!t.some((t=>t%1!==0)),y=t=>t instanceof R,x=t=>t instanceof G,g=t=>t instanceof F,v=t=>"function"===typeof HTMLVideoElement&&t instanceof HTMLVideoElement,S=t=>"function"===typeof HTMLCanvasElement?t instanceof HTMLCanvasElement:"getContext"in t,m=t=>/^[A-Za-z](\w+)?$/.test(t);Error;function b(t,e){console.warn(`GammaCV Deprecation Warning: "${t}" is deprecated${e?`, ${e}`:""}. "${t}" will be removed in next major version.`)}function k(){try{return d("canvas"),document.createElement("canvas")}catch(t){return h("function"===typeof OffscreenCanvas,"OffscreenCanvas"),new OffscreenCanvas(1,1)}}const T={};const E={SUPPORTS_FLOAT_TEXTURES:function(){const t=k().getContext("webgl");if(!t)return!1;if(!t.getExtension("OES_texture_float"))return!1;const e=t.createFramebuffer(),a=t.createTexture();T.MAX_TEXTURE_SIZE=t.getParameter(t.MAX_TEXTURE_SIZE),t.bindTexture(t.TEXTURE_2D,a),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,e),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,a,0);const n=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;let i;try{t.readPixels(0,0,1,1,t.RGBA,t.FLOAT,new Float32Array(4)),i=t.getError()===t.NO_ERROR}catch(r){i=!1}return n&&i}(),DEBUG:!1,MAX_TEXTURE_SIZE:T.MAX_TEXTURE_SIZE},_=Object.assign({},E);function C(t){let e="\nvoid main(void) {\n  vec2 coords = gl_FragCoord.xy - 0.5;\n  vec4 result = operation(coords.y, coords.x);\n\n  gl_FragColor = result;\n}\n  ";return _.SUPPORTS_FLOAT_TEXTURES||"float32"!==t.dtype||(e="\n    void main(void) {\n      vec2 coords = gl_FragCoord.xy;\n\n      highp float ox = floor(coords.x / 4.0);\n      float dx = floor(coords.x - ox * 4.0 + 0.5);\n    \n      vec4 result = operation(coords.y - 0.5, floor((coords.x - 0.5) / 4.0));\n\n      float value;\n\n      if (dx == 1.0) {\n        value = result.r;\n      } else if (dx == 2.0) {\n        value = result.g;\n      } else if (dx == 3.0) {\n        value = result.b;\n      } else if (dx == 4.0) {\n        value = result.a;\n      }\n    \n      gl_FragColor = encode_float(value);\n    }\n    "),e}var I=Object.freeze({main:C,pickValue:function(t){const e=Object.keys(t.input),a=[];for(let n=0;n<e.length;n+=1){const i=e[n];if(!t.input[i].shape)continue;const r=[...t.input[i].shape],o=r[1].toFixed(1),s=r[0].toFixed(1),l=(4*r[1]).toFixed(1);let c=(t,e,a)=>`${t} ${e}_${i}(float y, float x) {\n\treturn texture2D(${i}, vec2((x + 0.5) / ${o}, (y + 0.5) / ${s}))${a};\n}`;_.SUPPORTS_FLOAT_TEXTURES||"float32"!==t.input[i].dtype||(c=(t,e,a)=>`\n        ${t} ${e}_${i}(float y, float x) {\n          float r = decode_float(texture2D(${i}, vec2((x * 4.0 + 0.5) / ${l}, y / ${s})));\n          float g = decode_float(texture2D(${i}, vec2((x * 4.0 + 1.5) / ${l}, y / ${s})));\n          float b = decode_float(texture2D(${i}, vec2((x * 4.0 + 2.5) / ${l}, y / ${s})));\n          float a = decode_float(texture2D(${i}, vec2((x * 4.0 + 3.5) / ${l}, y / ${s})));\n\n          return vec4(r, g, b, a)${a};\n        }\n      `),a.push(c("vec4","pickValue","")),a.push(c("float","pickScalarValue",".x"))}return a.join("\n")},float:()=>"precision highp float;highp vec4 encode_float(highp float f){if(f==1./0.){return vec4(0.0,0.0,128.0,127.0)/255.0;}highp vec4 rgba;highp float e=5.0;highp float F=abs(f);highp float sign=step(0.0,-f);highp float exponent=floor(log2(F));highp float mantissa=(exp2(-exponent)*F);exponent=floor(log2(F)+127.0)+floor(log2(mantissa));rgba[0]=128.0*sign+floor(exponent*exp2(-1.0));rgba[1]=128.0*mod(exponent,2.0)+mod(floor(mantissa*64.0*2.0),128.0);rgba[2]=floor(mod(floor(mantissa*exp2(23.0-8.0)),exp2(8.0)));rgba[3]=floor(exp2(23.0)*mod(mantissa,exp2(-15.0)));return rgba.abgr/255.0;}float decode_float(highp vec4 rgba){rgba=rgba.abgr*255.0;highp float sign=1.0-step(128.0,rgba[0])*2.0;highp float exponent=2.0*mod(rgba[0],128.0)+step(128.0,rgba[1])-127.0;exponent=floor(exponent+0.5);highp float mantissa=mod(rgba[1],128.0)*32768.0*2.0+rgba[2]*256.0+rgba[3]+float(0x800000);highp float result=sign*mantissa*exp2(-23.0)*exp2(exponent);return result;}"});function A(t){return["bool","int","uint","float","double","vec2","vec3","vec4","mat2","mat3","mat4","sampler2D"].indexOf(t)>=0}function w(t){let e=typeof t;t=String(t);const a=/^(vec\d|mat\d)\([^)]+\)$/.exec(t);return a?e=a[1]:/^\d+$/.exec(t)?e="int":/^\d+\.(\d+)?$/.exec(t)?e="float":"boolean"===e&&(e="bool"),e}function V(t){let e;if(a=t.kernel,/void main\(([^)]+)?\)([\s]+)?{/.exec(a))e=t.kernel;else{const a=function(t){const e=Object.assign({},t.uniform),a=Object.keys(t.input);let n="precision highp float;\n";for(let o=0;o<a.length;o+=1)e[a[o]]={dtype:"sampler2D"};const i=Object.keys(e);for(let o=0;o<i.length;o+=1){const t=i[o];if(!A(e[t].dtype))throw new Error(`KernelConstructor: Uniform ${t} has invalid type "${e[t].dtype}"`);n+=`uniform ${e[t].dtype} ${t};\n`}n+="varying vec2 texCoords;\n";const r=Object.keys(t.constant);for(let o=0;o<r.length;o+=1){const e=r[o];let a=t.constant[e];"number"===typeof a&&a%1===0&&(a=a.toFixed(1));const i=w(a);if(!A(i))throw new Error(`KernelConstructor: Constant ${e}, has invalid type "${i}"`);n+=`#define ${e} ${a}\n`}return n}(t),n=function(t){const e=[];return _.SUPPORTS_FLOAT_TEXTURES||e.push("float"),e.concat(t.chunks.filter(((t,e,a)=>a.indexOf(t)===e))).map((e=>{const a=` Chunk ${e} `,n=35-a.length,i=`${"-".repeat(Math.floor(n/2))}${a}${"-".repeat(Math.ceil(n/2))}`;if("function"===typeof I[e])return`/*${i}*/\n${I[e](t)}\n/*${"-".repeat(35)}*/`;throw new TypeError(`KernelConstructor: Chunk "${e}" is not a function`)})).join("\n")}(t),i=C(t);e=[a,n,t.kernel,i].join("\n\n")}var a;return _.DEBUG&&(console.groupCollapsed(t.name),console.log(l(e).join("\n")),console.groupEnd()),e}class R extends n{constructor(t){h("undefined"!==typeof t,"Operation: Operation should have a name"),super(t),this.dtype=null,this.input={},this.uniform={},this.constant={},this.chunks=[],this.inputKeys=[],this.isInitialized=!1,this.lastCtx=Math.random(),this.cache=!0}run(t,e,a){h(this.isInitialized,"Operation: Unable to run uninitialized operation.");const n=this.gl,i=t.texture[this.name];if(e===this.lastCtx&&this.cache&&!a)return i.bind(this.program,!1,this.inputKeys.length),this.bindBuffer(),!1;this.lastCtx=e,n.useProgram(this.program);for(let r=0;r<this.inputKeys.length;r+=1){const e=this.inputKeys[r],a=this.input[e],n=a.name,i=t.texture[n];i.bind(this.program,e,r),g(a)&&i.set(a),x(a)&&i.set(a.media)}return i.bind(this.program,!1,this.inputKeys.length),this.bindBuffer(),_.SUPPORTS_FLOAT_TEXTURES?n.viewport(0,0,this.shape[1],this.shape[0]):n.viewport(0,0,("float32"===this.dtype?4:1)*this.shape[1],this.shape[0]),n.clearColor(0,0,0,1),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0),!0}unbindBuffer(){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null)}bindBuffer(){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer)}init(t){if(!this.isInitialized){if(this.gl=t,this.program=t.createProgram(),this.framebuffer=t.createFramebuffer(),this.isInitialized)return!1;this.constant.OUT_VIEW=`vec2(${this.shape[1]}, ${this.shape[0]})`,this.kernel=V(this);try{this.vertexShader=this.getShader("vertex","precision highp float;attribute vec3 aVertexPosition;attribute vec2 aTextureCoords;varying vec2 texCoords;void main(void){texCoords=aTextureCoords;gl_Position=vec4(aVertexPosition,1.0);}"),t.attachShader(this.program,this.vertexShader),this.fragmentShader=this.getShader("fragment",this.kernel),t.attachShader(this.program,this.fragmentShader),t.linkProgram(this.program),t.useProgram(this.program)}catch(e){throw c(this.kernel,this.name,e),new Error(`Operation: Error during shader compilation.\n${e.message}`)}this.attributes={aVertexPosition:new r(this.gl,this.program,"aVertexPosition","vec3"),aTextureCoords:new r(this.gl,this.program,"aTextureCoords","vec2"),aIndices:new r(this.gl,this.program,"aIndices","int")},this.attributes.aVertexPosition.set([1,1,0,-1,1,0,-1,-1,0,1,-1,0]),this.attributes.aTextureCoords.set([1,1,0,1,0,0,1,0]),this.attributes.aIndices.set([0,1,2,0,2,3]);const a=Object.keys(this.uniform);for(let t=0;t<a.length;t+=1){const e=this.uniform[a[t]];this.uniform[a[t]]=new i(this.gl,this.program,e.name,e.dtype),e.defaultValue&&this.uniform[a[t]].set(e.defaultValue)}this.isInitialized=!0}return!0}getShader(t,e){const a=this.gl;let n=null;if(n="fragment"===t?a.createShader(a.FRAGMENT_SHADER):a.createShader(a.VERTEX_SHADER),a.shaderSource(n,e),a.compileShader(n),!a.getShaderParameter(n,a.COMPILE_STATUS))throw new Error(`Operation: An error occurred compiling the shaders.\n${a.getShaderInfoLog(n)}`);return n}traverse(t,e){const a=Object.keys(this.input);for(let n=0;n<a.length;n+=1){const i=a[n];y(this.input[i])?this.input[i].traverse(t,e):t(this.input[i],e)}t(this,e)}getDependencies(){const t=[],e=Object.keys(this.input);for(let a=0;a<e.length;a+=1){const n=e[a];if(y(this.input[n])){const e=this.input[n].getDependencies();for(let a=0;a<e.length;a+=1)-1===t.indexOf(e[a])&&t.push(e[a])}}return t.push(this.name),t}assignInput(t,e){this.input[t]=e,-1===this.inputKeys.indexOf(t)&&this.inputKeys.push(t)}cloneProp(t){const e=Object.keys(this[t]),a={};for(let n=0;n<e.length;n+=1){const i=e[n];a[i]=this[t][i]}return a}destroy(){this.program&&this.gl.deleteProgram(this.program),this.vertexShader&&this.gl.deleteShader(this.vertexShader),this.fragmentShader&&this.gl.deleteShader(this.fragmentShader),this.framebuffer&&this.gl.deleteFramebuffer(this.framebuffer)}clone(){const t=new R(this.name.split(":")[0]);return t.input=this.cloneProp("input"),t.uniform=this.cloneProp("uniform"),t.constant=this.cloneProp("constant"),t.dtype=this.dtype,t.kernel=this.kernel,t.chunks=this.chunks,t}}class L{constructor(t,e,a,n){if("float32"!==t&&"uint8"!==t)throw new Error(`GPUTexture: Invalid texture type, currently supported is: float32, uint8, but got ${t} `);this.unit=a,this.dtype=t,this.gl=e,this.ctx=e.createTexture(),this.shape=n,e.bindTexture(e.TEXTURE_2D,this.ctx),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),this.allocate()}allocate(){const t=this.gl;let e=this.shape[1],a=t.UNSIGNED_BYTE;"float32"===this.dtype&&(_.SUPPORTS_FLOAT_TEXTURES?a=t.FLOAT:e*=4),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e,this.shape[0],0,t.RGBA,a,null)}set(t=null){const e=this.gl;if(v(t)||S(t))e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t);else{let a=t.shape[1],n=e.UNSIGNED_BYTE,i=t.data;"float32"===t.dtype&&(_.SUPPORTS_FLOAT_TEXTURES?n=e.FLOAT:(a*=4,i=t.uint8View)),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,a,this.shape[0],0,e.RGBA,n,i)}}bind(t,e,a){const n=this.gl;if(e){const i=n.getUniformLocation(t,e);n.uniform1i(i,a)}n.activeTexture(n.TEXTURE0+a),n.bindTexture(n.TEXTURE_2D,this.ctx),this.unit=a}unbind(){const t=this.gl;t.activeTexture(t.TEXTURE0+this.unit),t.bindTexture(t.TEXTURE_2D,null)}delete(){const t=this.gl;t.deleteTexture(this.ctx),this.gl=null,this.program=null,this.ctx=null,t.bindTexture(t.TEXTURE_2D,null)}}class O{constructor(){this.canvas=k(),this.canvas.width=1,this.canvas.height=1,this.initWebGL(this.canvas),this.operation={},this.texture={},this.textureCount=0}initWebGL(t,e){this.canvas=t;const a=this.canvas.getContext("webgl",e);h(!!a,"Session: WebGL not supported.");const n=a.getExtension("OES_texture_float");h(!!n,"Session: Unable to find extension OES_texture_float"),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),this.gl=a}init(t){h(!!t,"Session: Unable to initialize undefined operation"),h(y(t)||g(t),"Session: Unable to initialize operation with invalid input type"),y(t)&&t.traverse(((t,e)=>{e.operation[t.name]=t}),this),(g(t)||x(t))&&(this.operation[t.name]=t),this.update()}update(){const t=this.gl,e=Object.keys(this.operation);for(let a=0;a<e.length;a+=1){const n=this.operation[e[a]];n instanceof R&&n.init(this.gl),this.texture[e[a]]||(this.texture[e[a]]=new L(n.dtype,this.gl,this.textureCount,n.shape),n instanceof R&&(t.bindFramebuffer(t.FRAMEBUFFER,n.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture[e[a]].ctx,0),t.bindFramebuffer(t.FRAMEBUFFER,null)),this.textureCount+=1)}}runOp(t,e,a=!1){const n=t.sequence;let i=!1;for(let r=0;r<n.length;r+=1){const o=n[r],s=this.operation[o],l=r===n.length-1;h(!!s,`Session: Unable to run uninitialized operation ${t.name}.`),S(a)&&l&&(this.canvas.width===s.shape[1]&&this.canvas.height===s.shape[0]||(this.canvas.width=s.shape[1],this.canvas.height=s.shape[0]),s.framebuffer=null),i=!!s.run(this,e,i),a&&l&&g(a)&&this.readToTensor(a),a&&l&&S(a)&&this.readToCanvas(a,s.shape)}}destroy(){const t=this.gl.getExtension("WEBGL_lose_context"),e=Object.keys(this.texture),a=Object.keys(this.operation);t&&t.loseContext();for(let n=0;n<e.length;n+=1)this.texture[e[n]].delete();for(let n=0;n<a.length;n+=1){const t=this.operation[a[n]];t instanceof R&&t.destroy()}this.canvas=null,this.operation={},this.texture={},this.gl=null,this.textureCount=0}readToTensor(t){const e=this.gl,a=t.shape[0];let n=t.shape[1],i=e.UNSIGNED_BYTE,r=t.data;"float32"===t.dtype&&(_.SUPPORTS_FLOAT_TEXTURES?i=e.FLOAT:(n*=4,r=t.uint8View)),e.readPixels(0,0,n,a,e.RGBA,i,r)}readToCanvas(t,e){const a=t.getContext("2d");t.width=e[1],t.height=e[0],a.drawImage(this.canvas,0,0,e[1],e[0],0,0,e[1],e[0])}}class M{constructor(t){this.op=new R(t),this.name=t,this.checkShape=t=>t[Object.keys(t)[0]],this.preCompile=()=>{},this.postCompile=()=>{},this.chunks=[]}GLSLKernel(t){return h("string"===typeof t,"RegisterOperation: The kernel should be a string but it is not."),this.op.kernel=t,this}LoadChunk(...t){for(const a of t)h((e=a,u.includes(e)),`RegisterOperation: There is no available GLSL chunk supported: ${a}`);var e;return this.op.chunks=this.op.chunks.concat(t),this}Input(t,e){return h(m(t)),this.op.input[t]={name:t,dtype:e},this}Output(t){return h(null===this.op.dtype,"RegisterOperation: The operation allows a single output."),this.op.dtype=t,this}Constant(t,e){return h(m(t)),this.op.constant[t]=e,this}SetShapeFn(t){return h("function"===typeof t,"RegisterOperation: SetShapeFn should receive function in first argument"),this.checkShape=t,this}PreCompile(t){return h("function"===typeof t,"RegisterOperation: PreCompile should receive function in first argument"),this.preCompile=t,this}PostCompile(t){return h("function"===typeof t,"RegisterOperation: PostCompile should receive function in first argument"),this.postCompile=t,this}Uniform(t,e,a){return h(m(t)),this.op.uniform[t]={name:t,dtype:e,defaultValue:a},this}Compile(t){const e=this.op.clone(),a={},n=Object.keys(t);this.preCompile(e);for(let i=0;i<n.length;i+=1){const r=n[i],o=t[r];h(!!o,`RegisterOperation:${e.name}.${r}:\n         Can't compile operation with undefined input.`),h(g(o)||x(o)||y(o),`RegisterOperation:${e.name}.${r}:\n         Can't compile operation with invalid input type.\n         You can only use Tensor or another Operation to be an input`),a[r]=t[r].shape,e.assignInput(r,t[r])}return e.shape=this.checkShape(a),e.sequence=e.getDependencies(),e}}function U(t,e=!1){let a=null;return y(t)&&(a=new F(e||t.dtype,t.shape)),g(t)&&(a=new F(e||t.dtype,t.shape)),x(t)&&(a=new F(e||t.dtype,t.shape)),a}function K(t,e){if(e.data.set)e.data.set(t.data);else for(let a=0;a<e.size;a+=1)e.data[a]=t.data[a]}function P(t,e=[1,t.length,4],a="float32",n){const i=new Array(4*t.length);for(let r=0;r<i.length;r+=1)i[r]=(r+1)%4===0&&"number"===typeof n?n:t[~~(r/4)];return new F(a,e,F.GetTypedArray(a,i))}class F extends n{constructor(t,e,a,n,i=0){super("Tensor"),this.dtype=t,this.shape=e||[a.length],h(p(this.shape),"Tensor: Shape is not valid"),n&&(h(p(n),"Tensor: Stride is not valid"),h(this.shape.length===n.length,"Tensor: Stride length should be equal to shape length")),h("number"===typeof i&&i%1===0,`Tensor: Offset should be integer, but got ${i}`),this.size=F.GetSize(this.shape),this.stride=n||this._defineStride(this.shape),this.offset=i,this._compileJITMethods(),"undefined"===typeof a?(this.data=F.Malloc(t,this.size),this.empty=F.Malloc(t,this.size)):this.assign(a),_.SUPPORTS_FLOAT_TEXTURES||"float32"!==t||(this.uint8View=new Uint8Array(this.data.buffer))}_compileJITMethods(){const t=function(t){const e=new Array(t);for(let a=0;a<t;a+=1)e[a]=a;return e}(this.shape.length),e=t.map((t=>`i${t}`)).join(","),a=`${this.offset}+${t.map((t=>`${this.stride[t]}*i${t}`)).join("+")}`;this.get=new Function(`return function get(${e}) { return this.data[${a}]; }`)(),this.set=new Function(`return function get(${e}, v) { this.data[${a}] = v; }`)(),this.index=new Function(`return function get(${e}, v) { return ${a}; }`)()}_defineStride(t){const e=t.length,a=new Array(e);for(let n=e-1,i=1;n>=0;n-=1)a[n]=i,i*=this.shape[n];return a}assign(t){const e=F.DefineType(t),a=t.length;return h(e===this.dtype,`Tensor: Different dtypes assigned: \n   expected - ${this.dtype} \n   actual - ${e}`),h(a===this.size+this.offset,`Tensor: Different sizes assigned: \n   expected - ${this.size+this.offset} \n   actual - ${a}`),this.data=t,this}release(){return this.empty?this.data.set(this.empty):this.data=F.Malloc(this.dtype,this.size),this}relese(){return b("Tensor: relese"),this.release(),this}clone(){const t=new F(this.dtype,this.shape,void 0,this.stride,this.offset);return K(this,t),t}static IndexToCoord(t,e){const a=new Array(t.length);let n=e,i=t.reduce(((t,e)=>t*e));for(let r=0;r<=t.length-2;r+=1){i/=t[r];const e=~~(n/i);n%=i,a[r]=e}return a[a.length-1]=n%t[t.length-1],a}static CoordToIndex(t,e){let a=1,n=0;for(let i=t.length-1;i>=0;i-=1)n+=a*e[i],a*=t[i];return n}static Malloc(t,e){switch(t){case"uint8":return new Uint8Array(e);case"uint16":return new Uint16Array(e);case"uint32":return new Uint32Array(e);case"int8":return new Int8Array(e);case"int16":return new Int16Array(e);case"int32":return new Int32Array(e);case"float32":return new Float32Array(e);case"float64":return new Float64Array(e);case"uint8c":return new Uint8ClampedArray(e);case"array":return new Array(e);default:throw new Error(`Tensor: Unexpected type: ${t}.`)}}static DefineType(t){const e=Object.prototype.toString.call(t);switch(e){case"[object Uint8Array]":return"uint8";case"[object Uint16Array]":return"uint16";case"[object Uint32Array]":return"uint32";case"[object Int8Array]":return"int8";case"[object Int16Array]":return"int16";case"[object Int32Array]":return"int32";case"[object Float32Array]":return"float32";case"[object Float64Array]":return"float64";case"[object Uint8ClampedArray]":return"uint8c";case"[object Array]":return"array";default:throw new Error(`Tensor: Unknown dtype: ${e}.`)}}static GetTypedArray(t,e){if(t===F.DefineType(e))return e;switch(t){case"uint8":return new Uint8Array(e);case"uint16":return new Uint16Array(e);case"uint32":return new Uint32Array(e);case"int8":return new Int8Array(e);case"int16":return new Int16Array(e);case"int32":return new Int32Array(e);case"float32":return new Float32Array(e);case"float64":return new Float64Array(e);case"uint8c":return new Uint8ClampedArray(e);case"array":return new Array(e);default:throw new Error(`Unknown type: ${t}.`)}}static GetSize(t){return t.reduce(((t,e)=>t*e),1)}}class G extends n{constructor(t,e){super("MediaInput"),this.dtype="uint8",this.inputKeys=[],this.isInitialized=!1,this.lastCtx=Math.random(),this.cache=!0,this.assignMedia(t,e)}assignMedia(t,e){t&&h(v(t)||S(t),"MediaInput: Is only Video, Canvas element available as input"),e&&h(p(e),"MediaInput: Shape is invalid"),this.media=t,this.shape=e}}function H(t,e,a=!1,n=!1){if(!(e instanceof F))throw Error("tensorToCanvas: Input tensor invalid");e.shape[2]&&4===e.shape[2]&&(a=!0);const i=function(t,e=!1,a=!1){const n=new ImageData(t.shape[1],t.shape[0]),i=t.shape[0]*t.shape[1];if(e&&"uint8"===t.dtype)return n.data.set(t.data),n;if(!e){for(let e=0;e<i;e+=1){const i=~~(e/t.shape[0]),r=e-i*t.shape[1],o=t.data[e];let s=0;s=a?4*(r*t.shape[0]+i):4*(i*t.shape[1]+r),n.data[s+0]=o,n.data[s+1]=o,n.data[s+2]=o,n.data[s+3]=255}return n}if("float32"===t.dtype)for(let r=0;r<t.size;r+=1)n.data[r]=255*t.data[r];else for(let r=0;r<t.size;r+=1)n.data[r]=t.data[r];return n}(e,a,n);t.getContext("2d").putImageData(i,0,0)}const D=(t,e,a="rgba(255, 0, 0, 0.5)",n=1)=>{const i=t.getContext("2d");i.beginPath(),Array.isArray(e)?(i.moveTo(e[0],e[1]),i.lineTo(e[2],e[3])):(i.moveTo(e.data[0],e.data[1]),i.lineTo(e.data[2],e.data[3])),i.strokeStyle=a,i.lineWidth=n,i.stroke(),i.closePath()},$=t=>{t.getContext("2d").clearRect(0,0,t.width,t.height)};function B(t,e){const a=t.getContext("2d");a.fillStyle=e,a.fillRect(0,0,t.width,t.height)}function X(t,e){return t*e}function W(t,e){return e/t}function N(t,e,a){if(e){const n=W(t,e);if(n>a)return{width:e,height:n}}return{width:X(t,a),height:a}}class z{static IsAvailable(){const t={video:{width:{min:480,ideal:1080,max:1920},height:{min:480,ideal:1080,max:1920}}};navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia||navigator.oGetUserMedia;const e=navigator.userAgent;-1!==e.indexOf("Safari")&&-1===e.indexOf("Chrome")&&(delete t.video.width,delete t.video.height);let a=Promise.resolve();return navigator.mediaDevices&&navigator.mediaDevices.getUserMedia?a=a.then((()=>navigator.mediaDevices.getUserMedia(t))):navigator.getUserMedia&&(a=a.then((()=>new Promise((e=>navigator.getUserMedia(t,e)))))),a.then((t=>{const e=t.getTracks(),a=e[0].getSettings().deviceId;return e.forEach((t=>t.stop())),a||!0})).catch((()=>Promise.resolve(!1)))}static getDevices(){return"mediaDevices"in navigator&&"enumerateDevices"in navigator.mediaDevices?navigator.mediaDevices.enumerateDevices().then((t=>t.filter((t=>"videoinput"===t.kind)))):Promise.resolve(null)}constructor(t,e){this.video=(d("video"),document.createElement("video")),this.video.muted=!0,this.video.playsInline=!0,this.canvas=k(),this.canvasCtx=this.canvas.getContext("2d"),this.sourceCanvas=k(),this.sourceCanvasCtx=this.sourceCanvas.getContext("2d"),this.width=t,this.height=e,this.sourceWidth=t,this.sourceHeight=e,this.setSize(t,e),this.track=null}setSize(t,e){this.width=t,this.height=e,this.canvas.width=t,this.canvas.height=e,this.sourceCanvas.width=t,this.sourceCanvas.height=e,this.sourceMinWidth=t,this.sourceMinHeight=e}setSourceSize(t,e){const a=N(t/e,this.width,this.height),n=function(t,e,a){if(e){const n=W(t,e);if(n<=a)return{width:e,height:n}}return{width:X(t,a),height:a}}(this.width/this.height,t,e),i=N(t/e,n.width,n.height);this.sourceMinWidth=a.width,this.sourceMinHeight=a.height,this.sourceWidth=i.width,this.sourceHeight=i.height,this.sourceCanvas.width=n.width,this.sourceCanvas.height=n.height}getDevice(){return this.track?this.track.getSettings().deviceId:null}start(t,e=""){this.started=!0;const a={video:{width:{min:240,ideal:1080,max:1920},height:{min:240,ideal:1080,max:1920},aspectRatio:{exact:this.width/this.height},deviceId:t?{ideal:t}:void 0,facingMode:e?{exact:e}:null}},n=navigator.userAgent,i=!(-90===window.orientation||90===window.orientation||window.offsetWidth>window.offsetHeight);/android/i.test(n)&&i&&(a.video.aspectRatio.exact=1/a.video.aspectRatio.exact),-1!==n.indexOf("Safari")&&-1===n.indexOf("Chrome")&&(delete a.video.width,delete a.video.height,delete a.video.aspectRatio),navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia||navigator.oGetUserMedia;let r=Promise.resolve();return navigator.mediaDevices&&navigator.mediaDevices.getUserMedia?r=r.then((()=>navigator.mediaDevices.getUserMedia(a))):navigator.getUserMedia&&(r=r.then((()=>new Promise((t=>navigator.getUserMedia(a,t)))))),r.then((t=>{if(t){const e=t.getTracks();return this.started?("srcObject"in this.video?this.video.srcObject=t:this.video.src=window.URL.createObjectURL(t),this.track=e[0],this.video.play().then((()=>this.setSourceSize(this.video.videoWidth,this.video.videoHeight)))):(e.forEach((t=>t.stop())),null)}throw new Error("getUserMedia not found or no stream was created")}))}stop(){this.started=!1,this.track&&(this.track.stop(),this.track=null)}drawImage(t,e,a,n,i){t.drawImage(this.video,(n-e)/-2,(i-a)/-2,n,i)}getImageBuffer(t,e=this.canvasCtx,a=this.width,n=this.height,i=0,r=0,o=a,s=n,l=this.sourceMinWidth,c=this.sourceMinHeight){this.drawImage(e,o,s,l,c);const u=e.getImageData(i,r,o,s);if(t instanceof F)return t.data.set(u.data),t;switch(t){case"uint8":return new Uint8Array(u.data);case"uint8c":return u.data;case"float32":return new Float32Array(u.data);default:return u}}getImageBufferTo(t,e=this.canvasCtx,a=this.width,n=this.height,i=0,r=0,o=a,s=n,l){e.drawImage(this.video,(this.sourceWidth-this.width)/-2,(this.sourceHeight-this.height)/-2,this.sourceWidth,this.sourceHeight);const c=e.getImageData(i,r,o,s);l.data=c.data.buffer}getSourceImageBuffer(t,e,a,n,i){return this.getImageBuffer(t,this.sourceCanvasCtx,this.sourceCanvas.width,this.sourceCanvas.height,e,a,n,i,this.sourceWidth,this.sourceHeight)}}var j=t=>new M("Grayscale").Input("tSrc","uint8").Output("uint8").LoadChunk("pickValue").GLSLKernel("const vec3 k=vec3(0.2128,0.7148,0.0724);vec4 operation(float y,float x){float value=dot(pickValue_tSrc(y,x).rgb,k);return vec4(value,value,value,1.0);}").Compile({tSrc:t});function Y(t=3,e=1){const a=new F("float32",[t,t]),n=(t-1)/2,i=new F("float32",[t,t,4]);let r=0;for(let o=0;o<t;o+=1)for(let i=0;i<t;i+=1){const t=Math.exp(-.5*(((i-n)/e)**2+((o-n)/e)**2))/(2*Math.PI*e*e);a.set(i,o,t),r+=a.get(i,o)}for(let o=0;o<t;o+=1)for(let e=0;e<t;e+=1)i.set(e,o,0,a.get(e,o)/r),i.set(e,o,1,a.get(e,o)/r),i.set(e,o,2,a.get(e,o)/r);return i}var q=(t,e,a=1,n=0)=>new M("Convolution2d").Input("tSrc",t.dtype).Input("tKernel","float32").Output(t.dtype).LoadChunk("pickValue").Constant("KERNEL_WIDTH",e.shape[1]).Constant("KERNEL_HEIGHT",e.shape[0]).Uniform("bias","float",n).Uniform("factor","float",a).GLSLKernel("const float hWidth=(KERNEL_WIDTH-1.0)/2.0;const float hHeight=(KERNEL_HEIGHT-1.0)/2.0;vec4 operation(float y,float x){vec3 finalColour=vec3(0.0);for(float dy=-hHeight;dy<=hHeight;dy+=1.0){for(float dx=-hWidth;dx<=hWidth;dx+=1.0){vec3 k=pickValue_tKernel(float(dy+hHeight),float(dx+hWidth)).rgb;finalColour+=pickValue_tSrc(y+dy,x+dx).rgb*k;}}return vec4(finalColour*factor+bias,1.0);}").Compile({tSrc:t,tKernel:e});const Z=Object.freeze({gaussianBlur:Y,boxBlur:function(t=3){const e=new F("float32",[t,t,4]),a=t**2;for(let n=0;n<e.data.length;n+=1)e.data[n]=1/a;return e},sharpen:function(t=1){const e=-1*t;return P([0,e,0,e,1+4*t,e,0,e,0],[3,3,4],"float32")},invert:function(){return P([0,0,0,0,-1,0,0,0,0],[3,3,4],"float32")},edgeDetection:function(){return P([1,0,-1,0,0,0,-1,0,1],[3,3,4],"float32")},edgeDetection2:function(){return P([0,1,0,1,-4,1,0,1,0],[3,3,4],"float32")},edgeDetection3:function(){return P([-1,-1,-1,-1,8,-1,-1,-1,-1],[3,3,4],"float32")},unsharpMasking:function(t=3,e=1,a=1){const n=Y(t,e),i=~~((t-1)/2),r=1+1*a-n.get(i,i,0),o=1+1*a-n.get(i,i,1),s=1+1*a-n.get(i,i,2);for(let l=0;l<n.size;l+=1)n.data[l]=-n.data[l];return n.set(i,i,0,r),n.set(i,i,1,o),n.set(i,i,2,s),n}});var J=(t,e=3,a=3)=>(h(e>=3,"Kernel size should be greater equal 3"),h(a>0,"Sigma should be greater then 0"),q(t,Y(e,a))),Q=(t,e,a,n="nearest")=>{h("nearest"===n||"bicubic"===n||"mean"===n||"max"===n,'ResizeOperation: Unsupported type of operation. Currently supported only "nearest" and "bicubic"'),"mean"===n&&(b('ResizeOperation: type "mean"','use "bicubic" instead'),n="bicubic"),"max"===n&&(b('ResizeOperation: type "max"','use "nearest" instead'),n="nearest"),h(e>0||a>0,"ResizeOperation: Size of image should be greater than 0");let i=0;return"nearest"===n?i=0:"bicubic"===n&&(i=1),new M("Resize").Input("tSrc",t.dtype).Output(t.dtype).Constant("TX",t.shape[1]/e).Constant("TY",t.shape[0]/a).Constant("S",i).SetShapeFn((()=>{const t=[a,e,4];return h((t=>t[0]>0&&t[1]>0)(t),"ResizeOperation: Invalid operation shape"),t})).LoadChunk("pickValue").GLSLKernel("vec4 operation(float j,float i){float x=floor(i*TX);float y=floor(j*TY);if(S==0.0){return pickValue_tSrc(y,x);}if(S==1.0){float dx=floor(TX*i)-x;float dy=floor(TY*j)-y;vec4 C[4];for(float jj=0.0;jj<=3.0;jj+=1.0){vec4 d0=pickValue_tSrc(y-1.0+jj,x-1.0)-pickValue_tSrc(y-1.0+jj,x);vec4 d2=pickValue_tSrc(y-1.0+jj,x+1.0)-pickValue_tSrc(y-1.0+jj,x);vec4 d3=pickValue_tSrc(y-1.0+jj,x+2.0)-pickValue_tSrc(y-1.0+jj,x);vec4 a0=pickValue_tSrc(y-1.0+jj,x);vec4 a1=-1.0/3.0*d0+d2-1.0/6.0*d3;vec4 a2=1.0/2.0*d0+1.0/2.0*d2;vec4 a3=-1.0/6.0*d0+1.0/2.0*d2+1.0/6.0*d3;C[int(jj)]=a0+a1*dx+a2*dx*dx+a3*dx*dx*dx;}vec4 d0=C[0]-C[1];vec4 d2=C[2]-C[1];vec4 d3=C[3]-C[1];vec4 a0=C[1];vec4 a1=-1.0/3.0*d0+d2-1.0/6.0*d3;vec4 a2=1.0/2.0*d0+1.0/2.0*d2;vec4 a3=-1.0/6.0*d0-1.0/2.0*d2+1.0/6.0*d3;vec4 Cc=a0+a1*dy+a2*dy*dy+a3*dy*dy*dy;return Cc;}}").Compile({tSrc:t})},tt=(t,e=2,a="nearest")=>{const n=~~(t.shape[1]/e),i=~~(t.shape[0]/e);return Q(t,n,i,a)},et=t=>new M("SobelOperator").Input("tSrc",t.dtype).Output("float32").Uniform("uWidth","float",t.shape[0]).Uniform("uHeight","float",t.shape[1]).Constant("PI",Math.PI).GLSLKernel("vec4 operation(float y,float x){float wk=1.0;float hk=1.0;float dx=0.0;float dy=0.0;dx+=-1.0*pickScalarValue_tSrc(y-hk,x-wk);dx+=-2.0*pickScalarValue_tSrc(y,x-wk);dx+=-1.0*pickScalarValue_tSrc(y+wk,x-wk);dx+=+1.0*pickScalarValue_tSrc(y-wk,x+wk);dx+=+2.0*pickScalarValue_tSrc(y,x+wk);dx+=+1.0*pickScalarValue_tSrc(y+wk,x+wk);dy+=-1.0*pickScalarValue_tSrc(y-wk,x-wk);dy+=-2.0*pickScalarValue_tSrc(y-wk,x);dy+=-1.0*pickScalarValue_tSrc(y-wk,x+wk);dy+=+1.0*pickScalarValue_tSrc(y+wk,x-wk);dy+=+2.0*pickScalarValue_tSrc(y+wk,x);dy+=+1.0*pickScalarValue_tSrc(y+wk,x+wk);float magniture=sqrt((dx*dx)+(dy*dy));float theta=atan(dy/dx);return vec4(magniture,dx,dy,theta);}").LoadChunk("pickValue").Compile({tSrc:t});const at=t=>new M("HOGDirection").Input("tSrc","uint8").Output("float32").Uniform("uWidth","float",t.shape[1]).Uniform("uHeight","float",t.shape[0]).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){float dx=pickValue_tSrc(y,x+1.0).r-pickValue_tSrc(y,x-1.0).r;float dy=pickValue_tSrc(y+1.0,x).r-pickValue_tSrc(y-1.0,x).r;float magniture=sqrt((dx*dx)+(dy*dy));return vec4(magniture,atan(dy/dx),dx,dy);}").Compile({tSrc:t});var nt=(t,e=10,a="max")=>{h("max"===a||"visualize"===a,"Unsupported type of HOG operation.\n     Currently availiable max and visualize.");let n=null;return"max"===a&&(n=((t,e)=>new M("HOGMax").Input("tSrc","uint8").Output("float32").Uniform("uSrcWidth","float",t.shape[1]).Uniform("uSrcHeight","float",t.shape[0]).Uniform("uWidth","float",~~(t.shape[1]/e)).Uniform("uHeight","float",~~(t.shape[0]/e)).Constant("PI",Math.PI).Constant("W",~~(t.shape[1]/e)).Constant("H",~~(t.shape[0]/e)).Constant("K",e).LoadChunk("pickValue").SetShapeFn((()=>[~~(t.shape[0]/e),~~(t.shape[1]/e),4])).GLSLKernel("const int w=int(W);const int h=int(H);const int k=int(K);const float S=3.0;float A=180.0/9.0;vec4 getPixel(float y,float x){float x1=x/float(w);float y1=y/float(h);return pickValue_tSrc(floor(y1*uSrcHeight),floor(x1*uSrcWidth));}vec4 getPixel(float y,float x,float xOffset,float yOffset){float x1=x/float(w);float y1=y/float(h);return pickValue_tSrc(floor(y1*uSrcHeight)+yOffset,floor(x1*uSrcWidth)+xOffset);}vec4 operation(float y,float x){float x1=x/W;float y1=y/H;float res=0.0;float tmpx=x/S;float tmpy=y/S;float sum[9];int count=0;vec4 value=getPixel(y,x);for(int _x=0;_x<k;_x+=1){for(int _y=0;_y<k;_y+=1){vec4 v=getPixel(y,x,float(_y),float(_x));float theta=abs(PI/2.0-v.g);float deg=theta*(180.0/PI);int i=int(floor(deg/A));if(i==1){sum[1]+=v.r;}if(i==2){sum[2]+=v.r;}if(i==3){sum[3]+=v.r;}if(i==4){sum[4]+=v.r;}if(i==5){sum[5]+=v.r;}if(i==6){sum[6]+=v.r;}if(i==7){sum[7]+=v.r;}if(i==8){sum[8]+=v.r;}}}int maxI=0;float maxV=0.0;for(int i=0;i<9;i++){if(maxV<sum[i]){maxI=i;maxV=sum[i];}}return vec4(maxI,maxV,0.0,0.0);}").Compile({tSrc:t}))(at(t),e)),"visualize"===a&&(n=((t,e)=>new M("HOG").Input("tSrc","uint8").Output("float32").Uniform("uSrcWidth","float",t.shape[1]).Uniform("uSrcHeight","float",t.shape[0]).Uniform("uWidth","float",3*~~(t.shape[1]/e)).Uniform("uHeight","float",3*~~(t.shape[0]/e)).Constant("PI",Math.PI).Constant("W",~~(t.shape[1]/e)).Constant("H",~~(t.shape[0]/e)).Constant("K",e).LoadChunk("pickValue").SetShapeFn((()=>[3*~~(t.shape[0]/e),3*~~(t.shape[1]/e),4])).GLSLKernel("float A=180.0/9.0;float S=3.0;vec4 operation(float y,float x){float my=y-(S*floor(y/S));float mx=x-(S*floor(x/S));x=x/S;y=y/S;float index=mx+(my*S);float sum=0.0;for(float dx=0.0;dx<K;dx+=1.0){for(float dy=0.0;dy<K;dy+=1.0){vec4 v=pickValue_tSrc(((y*K)+dy),((x*K)+dx));float theta=abs(PI/2.0-v.g);float deg=theta*(180.0/PI);float i=floor(deg/A);if(i==index){sum+=v.r;}}}float rad=(index/9.0*PI);return vec4(sum,rad,0.0,0.0);}").Compile({tSrc:t}))(at(t),e)),n},it=(t,e=t.dtype)=>new M("Cast").Input("tSrc",t.dtype).Output(e).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){return pickValue_tSrc(y,x);}").Compile({tSrc:t});var rt=(t,e=.25,a=.75)=>{return((t,e,a)=>(h(e>=0,"Canny low threshold should be greater equal 0"),h(a<=1,"Canny high threshold should be less equal 1"),new M("ImageCannyEdgesHysteresis").Input("tSrc",t.dtype).Output(t.dtype).LoadChunk("pickValue").Uniform("uSize","float",1).Uniform("uThresholdLow","float",e).Uniform("uThresholdHigh","float",a).GLSLKernel("\n#define STROKE uSize\nvec4 operation(float y,float x){vec4 M=pickValue_tSrc(y,x);float N=pickValue_tSrc(y+STROKE,x).r;float S=pickValue_tSrc(y-STROKE,x).r;float W=pickValue_tSrc(y,x-STROKE).r;float E=pickValue_tSrc(y,x+STROKE).r;float SE=pickValue_tSrc(y-STROKE,x+STROKE).r;float NW=pickValue_tSrc(y+STROKE,x-STROKE).r;float NE=pickValue_tSrc(y+STROKE,x+STROKE).r;float SW=pickValue_tSrc(y-STROKE,x-STROKE).r;float V=M.r;float H=0.0;if(V>uThresholdHigh){H+=1.0;}if(V>uThresholdLow&&V<uThresholdHigh){if(N>0.0||S>0.0||W>0.0||E>0.0||SE>0.0||NW>0.0||NE>0.0||SW>0.0){H+=1.0;}}if(H==1.0){return vec4(255,255,255,255);}else{return vec4(0,0,0,255);}}").Compile({tSrc:t})))((n=t,new M("ImageCannyEdgesNMS").Input("tSrc",n.dtype).Output(n.dtype).LoadChunk("pickValue").Uniform("uSize","float",1).Constant("PI",Math.PI).GLSLKernel("\n#define STROKE uSize\nvec4 operation(float y,float x){vec4 M=pickValue_tSrc(y,x);float N=pickValue_tSrc(y+STROKE,x).r;float S=pickValue_tSrc(y-STROKE,x).r;float W=pickValue_tSrc(y,x-STROKE).r;float E=pickValue_tSrc(y,x+STROKE).r;float SE=pickValue_tSrc(y-STROKE,x+STROKE).r;float NW=pickValue_tSrc(y+STROKE,x-STROKE).r;float NE=pickValue_tSrc(y+STROKE,x+STROKE).r;float SW=pickValue_tSrc(y-STROKE,x-STROKE).r;float H=0.0;float V=M.r;float dx=M.g;float dy=M.b;float theta=atan(dy/dx);float deg=theta*(180.0/PI);float angle=0.0;if(deg<0.0){deg=180.0+deg;}if(deg<22.5||deg>=157.5){if(V>W&&V>E){H+=1.0;}}if(deg<67.5&&deg>=22.5){if(V>SW&&V>NE){H+=1.0;}}if(deg<112.5&&deg>=67.5){if(V>N&&V>S){H+=1.0;}}if(deg<157.5&&deg>=112.5){if(V>NW&&V>SE){H+=1.0;}}if(H==1.0){return vec4(V,V,V,255);}else{return vec4(0,0,0,255);}}").Compile({tSrc:n})),e,a);var n},ot=(t,e=3)=>(h("uint8"===t.dtype,"Color Segmentation currently available for uint8 image input"),h(e>1,"Number of clusters should be greater than 1"),new M("ImageColorSegmentation").Input("tSrc","uint8").Input("tCentroids","uint8").Output("uint8").LoadChunk("pickValue").Constant("CLUSTERS",e).GLSLKernel("const float _step=1.0/CLUSTERS;vec4 operation(float y,float x){float minDistance=256.0;float label=0.0;vec3 value=pickValue_tSrc(y,x).rgb;for(int i=0;i<int(CLUSTERS);i+=1){vec3 curr=pickValue_tCentroids(float(i),0.0).rgb;float distance=sqrt(((value.r-curr.r)*(value.r-curr.r)));if(distance<minDistance){minDistance=distance;label=float(i)/CLUSTERS;}}return vec4(label,label,label,1.0);}").PreCompile((t=>{const a=~~(256/e);t.centroids=new F("uint8",[e,1,4]);for(let n=0;n<e;n+=1)t.centroids.set(n,0,0,n*a);t.assignInput("tCentroids",t.centroids)})).Compile({tSrc:t}));function st(t=1,e=[1]){let a=t;for(let n=0;n<e.length;n+=1)a/=e[n];return 1===a}function lt(t=[1,1],e=[[1,1]]){return st(t[0],e.map((t=>t[0])))&&st(t[0],e.map((t=>t[1])))}function ct(t=1,e=1,a=!0,n=t){const i=t**(1/e);if(t%1!==0)throw new RangeError(`Can't get parallel reduction steps for non-integer, got "${t}"`);if(n<1)throw new RangeError(`Can't get parallel reduction steps for maxLayerSize below less than 1, got "${n}"`);if(i%1===0&&i<n)return new Array(e).fill(i);const r=[];let o=t,s=i;for(let l=0;l<e;l+=1){s=o**(1/(e-l));let t=Math.ceil(s);for(;(o%t!==0||o/t>n)&&o/t!==1;)t+=1;if(1===t&&a)break;o/=t,r.push(t)}return r}function ut(t=[1,1],e=1,a=!0,n=t){const i=ct(t[0],e,a,n[0]),r=ct(t[1],e,a,n[1]),o=[];for(let s=0;s<e&&(i[s]||r[s]);s+=1)o.push([i[s]||1,r[s]||1]);return o}const ht=(t,e)=>new M("ImageReduceStd").Input("tStd",t.dtype).Output(t.dtype).Constant("WIDTH",t.shape[1]).Constant("HEIGHT",t.shape[0]).Uniform("uWidth","float",t.shape[1]/e[1]).Uniform("uHeight","float",t.shape[0]/e[0]).Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").SetShapeFn((()=>[~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1]),4])).GLSLKernel("const int kx=int(KX);const int ky=int(KY);const int w=int(WIDTH);const int h=int(HEIGHT);vec4 operation(float gly,float glx){float size=KX*KY;vec3 std=vec3(0.0,0.0,0.0);for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 mstd=pickValue_tStd(gly*KY+float(y),glx*KX+float(x)).rgb;std+=mstd*mstd;}}std/=size;std=sqrt(std);if(std.r==0.0){std.r=255.0;}if(std.g==0.0){std.g=255.0;}if(std.b==0.0){std.b=255.0;}return vec4(std,255.0);}").Compile({tStd:t}),ft=(t,e)=>new M("ImageExtractMean").Input("tSrc",t.dtype).Output(t.dtype).Constant("WIDTH",t.shape[1]).Constant("HEIGHT",t.shape[0]).Uniform("uWidth","float",t.shape[1]/e[1]).Uniform("uHeight","float",t.shape[0]/e[0]).Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").SetShapeFn((()=>[~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1]),4])).GLSLKernel("const int kx=int(KX);const int ky=int(KY);const int w=int(WIDTH);const int h=int(HEIGHT);vec4 operation(float gly,float glx){float size=KY*KX;float mean=0.0;float std=0.0;vec3 color=vec3(0.0,0.0,0.0);for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;color+=value.rgb;}}color/=size;mean=color.r;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;std+=(value.r-mean)*(value.r-mean);}}std/=size;std=sqrt(std);if(std==0.0){std=1.0;}return vec4(color,255.0);}").Compile({tSrc:t});var dt=(t,e=1,a)=>{let n=[[t.shape[0],t.shape[1]]];Array.isArray(e)?(h(lt(t.shape,e),"ImageMeanStd: Provided steps doesn't converge in 1 px in ImageExtractMeanStd operation"),n=e):"number"===typeof e&&e>0&&(n=ut(t.shape,e));let i=ft(t,n[0]);for(let l=1;l<n.length;l+=1)i=ft(i,n[l]);if(a)return i;let r=((t,e,a)=>new M("ImageExtractStd").Input("tSrc",t.dtype).Input("tMean",e.dtype).Output(t.dtype).Constant("WIDTH",t.shape[1]).Constant("HEIGHT",t.shape[0]).Uniform("uWidth","float",t.shape[1]/a[1]).Uniform("uHeight","float",t.shape[0]/a[0]).Constant("KX",a[1]).Constant("KY",a[0]).LoadChunk("pickValue").SetShapeFn((()=>[~~(t.shape[0]/a[0]),~~(t.shape[1]/a[1]),4])).GLSLKernel("const int kx=int(KX);const int ky=int(KY);const int w=int(WIDTH);const int h=int(HEIGHT);vec4 operation(float gly,float glx){float size=KX*KY;vec3 std=vec3(0.0,0.0,0.0);vec3 mean=pickValue_tMean(0.0,0.0).rgb;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;std+=(value-mean)*(value-mean);}}std/=size;std=sqrt(std);if(std.r==0.0){std.r=255.0;}if(std.g==0.0){std.g=255.0;}if(std.b==0.0){std.b=255.0;}return vec4(std,255.0);}").Compile({tSrc:t,tMean:e}))(t,i,n[0]);for(let l=1;l<n.length;l+=1)r=ht(r,n[l]);return o=i,s=r,new M("ImageJoin").Input("tMean",o.dtype).Input("tStd",s.dtype).Output(o.dtype).SetShapeFn((()=>[2,1,4])).GLSLKernel("vec4 operation(float gly,float glx){if(gly==0.0){return texture2D(tMean,vec2(0,0));}else{return texture2D(tStd,vec2(0,0));}}").Compile({tMean:o,tStd:s});var o,s};const pt=(t,e,a)=>new M("ImageReduceHistogram").Input("tSrc","float32").Output("float32").Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").Constant("COUNT",a).SetShapeFn((()=>[~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1]),4])).GLSLKernel("const int kx=int(KX);const int ky=int(KY);vec4 operation(float gly,float iglx){float size=KX*KY;float glx=floor(iglx/COUNT);float currentIndex=iglx-(glx*COUNT);vec4 count=vec4(0.0);for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){count+=pickValue_tSrc(gly*KY+float(y),(glx*KX+float(x))*COUNT+currentIndex);}}return count;}").Compile({tSrc:t});var yt=(t,e=1,a=0,n=1,i=1/255)=>{let r=[[t.shape[0],t.shape[1]]];const o=~~((n-a+i)/i);Array.isArray(e)?(h(lt(t.shape,e),"ImageExtractHistogram: Provided steps doesn't converge in 1 px in operation"),r=e):"number"===typeof e&&e>0&&(r=ut(t.shape,e,!0,[_.MAX_TEXTURE_SIZE,_.MAX_TEXTURE_SIZE/256/(_.SUPPORTS_FLOAT_TEXTURES?1:4)]));let s=((t,e,a,n,i,r)=>new M("ImageExtractHistogram").Input("tSrc",t.dtype).Output("float32").Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").Constant("MIN",a).Constant("MAX",n).Constant("STEP",i).Constant("COUNT",r).SetShapeFn((()=>[~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1])*r,4])).GLSLKernel("const int kx=int(KX);const int ky=int(KY);precision highp float;vec4 operation(float gly,float iglx){float size=KX*KY;float glx=floor(iglx/COUNT);float currentIndex=iglx-(glx*COUNT);vec4 count=vec4(0.0);vec4 ones=vec4(1.0);vec4 twos=vec4(2.0);vec4 currentIndex4=vec4(currentIndex);vec4 value;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x));vec4 index=floor((value-MIN)/STEP+0.5);count+=step(twos,ones/(abs(index-currentIndex4)));}}return count;}").Compile({tSrc:t}))(t,r[0],a,n,i,o);for(let l=1;l<r.length;l+=1)s=pt(s,r[l],o);return s};const xt=(t,e)=>new M("ImageReduceMinMax").Input("tSrc",t.dtype).Output(t.dtype).Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").SetShapeFn((()=>[~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1]),4])).GLSLKernel("const int kx=int(KX);const int ky=int(KY);const float INF=1.0/0.0;const float h2=OUT_VIEW.y/2.0;vec4 operation(float gly,float glx){float size=KX*KY;vec3 minV=vec3(INF);vec3 maxV=vec3(-INF);vec3 value;for(int y=0;y<ky;y+=1){for(int x=0;x<kx;x+=1){value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;minV=min(minV,value);maxV=max(maxV,value);}}if(gly<h2){return vec4(minV,255.0);}return vec4(maxV,255.0);}").Compile({tSrc:t});var gt=(t,e=1)=>{let a=[[t.shape[0],t.shape[1]]];Array.isArray(e)?(h(lt(t.shape,e),"ImageMeanStd: Provided steps doesn't converge in 1 px in ImageExtractMeanStd operation"),a=e):"number"===typeof e&&e>0&&(a=ut(t.shape,e));let n=((t,e)=>new M("ImageExtractMinMax").Input("tSrc",t.dtype).Output(t.dtype).Constant("KX",e[1]).Constant("KY",e[0]).LoadChunk("pickValue").SetShapeFn((()=>[2*~~(t.shape[0]/e[0]),~~(t.shape[1]/e[1]),4])).GLSLKernel("const int kx=int(KX);const int ky=int(KY);const float INF=1.0/0.0;const float h2=OUT_VIEW.y/2.0;vec4 operation(float igly,float glx){float size=KX*KY;vec3 minV=vec3(INF);vec3 maxV=vec3(-INF);float gly=igly;if(gly>=h2){gly-=h2;}for(int y=0;y<ky*2;y+=1){for(int x=0;x<kx;x+=1){vec3 value=pickValue_tSrc(gly*KY+float(y),glx*KX+float(x)).rgb;minV=min(minV,value.rgb);maxV=max(maxV,value.rgb);}}if(igly<h2){return vec4(minV,255.0);}else{return vec4(maxV,255.0);}}").Compile({tSrc:t}))(t,a[0]);for(let i=1;i<a.length;i+=1)n=xt(n,a[i]);return n},vt=(t,e={})=>new M("SkinTest").Input("tSrc",t.dtype).Output(t.dtype).Uniform("uRThreshold","float",e.uRThreshold||95).Uniform("uGThreshold","float",e.uGThreshold||40).Uniform("uBThreshold","float",e.uBThreshold||20).Uniform("uRtoMinDiffThreshold","float",e.uRtoMinDiffThreshold||15).Uniform("uRtoGDiffThreshold","float",e.uRtoGDiffThreshold||15).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 col=pickValue_tSrc(y,x)*255.0;float res=0.0;if((col.r>uRThreshold)&&(col.g>uGThreshold)&&(col.b>uBThreshold)&&(col.r>col.g)&&(col.r>col.b)&&(col.r-min(col.g,col.b)>uRtoMinDiffThreshold)&&(abs(col.r-col.g)>uRtoGDiffThreshold)){res=1.0;}return vec4(res,0.0,0.0,1.0);}").Compile({tSrc:t});var St=(t,e,a=3,n=10,i=10,r=!1,o=!0)=>new M("ImageStrokeWidthTransform").Input("tSobel","float32").Input("tCanny","uint8").Output("float32").LoadChunk("pickValue").Uniform("uStrokeMin","float",a).Uniform("uStrokeMax","float",n).Uniform("uWidth","float",t.shape[0]).Uniform("uHeight","float",t.shape[1]).Constant("STEPS",i).Constant("C",r?1:0).Constant("INVERT",o?1:0).Constant("PI",Math.PI).GLSLKernel("vec4 findForAngle(float theta,bool invert,float gly,float glx){const float thetaTreshold=PI/6.0;float PER_STEP=(uStrokeMax-uStrokeMin)/STEPS;if(invert){theta+=PI;}float sn=sin(theta);float cs=cos(theta);float tx=cs*PER_STEP;float ty=sn*PER_STEP;float minX=cs*uStrokeMin;float minY=sn*uStrokeMin;float strokeWidth=0.0;int intersect=0;int cx=0;int cy=0;for(int i=int(STEPS);i>0;i-=1){int nx=int(glx+minX+tx*float(i));int ny=int(gly+minY+ty*float(i));float dist=sqrt(float((nx-int(glx))*(nx-int(glx)))+float((ny-int(gly))*(ny-int(gly))));float cannyValue=pickValue_tCanny(float(ny),float(nx)).r;vec4 sobelValue=pickValue_tSobel(float(ny),float(nx));float theta2=atan(sobelValue.b,sobelValue.g);if(invert){theta2+=PI;}if(cannyValue>0.0&&dist>uStrokeMin&&dist<uStrokeMax&&abs(abs(theta-theta2)-PI)<thetaTreshold){strokeWidth=dist;cx=nx;cy=ny;}}return vec4(strokeWidth,cx,cy,theta);}vec4 operation(float _y,float _x){vec4 sobel=pickValue_tSobel(_y,_x);vec4 canny=pickValue_tCanny(_y,_x);float dx=sobel.g;float dy=sobel.b;float _theta=atan(dy,dx);vec4 result=findForAngle(_theta,INVERT>0.0,_y,_x);float strokeWidth=result.r;int cx=int(result.g);int cy=int(result.b);float theta=result.a;float a=float(cx)-_x;float b=float(cy)-_y;if(C>0.0){if(canny.r>0.0&&cx>0&&cy>0){return vec4(strokeWidth,theta,int(cx),int(cy));}else{return vec4(0,0,0,0);}}if(canny.r>0.0&&cx>0&&cy>0){return vec4(strokeWidth,theta,0,1.0);}else{return vec4(0,0,0,0);}}").Compile({tCanny:e,tSobel:t});var mt=(t,e,a=2)=>{h("l2"===e||"minmax"===e,"Unsupported type of normalization operation.\n     Currently availiable max and visualize.");let n=null;return"l2"===e&&(n=((t,e)=>new M("l2Norm").Input("tSrc","uint8").Input("tStdMean","uint8").Output("uint8").LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec3 chanels=pickValue_tSrc(y,x).rgb;vec3 mean=pickValue_tStdMean(0.0,0.0).rgb;vec3 std=pickValue_tStdMean(1.0,0.0).rgb;vec3 value=(chanels-mean)/std;return vec4(value,1.0);}").Compile({tSrc:t,tStdMean:e}))(t,dt(t,a))),"minmax"===e&&(n=((t,e)=>new M("minMaxNorm").Input("tSrc","uint8").Input("tMinMax","uint8").Output("uint8").LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec3 chanels=pickValue_tSrc(y,x).rgb;vec3 minV=pickValue_tMinMax(0.0,0.0).rgb;vec3 maxV=pickValue_tMinMax(1.0,0.0).rgb;vec3 value=(chanels-minV)/(maxV-minV);return vec4(value,1.0);}").Compile({tSrc:t,tMinMax:e}))(t,gt(t,a))),n};var bt=(t,e=2)=>((t,e)=>new M("histogramEqualization").Input("tSrc","uint8").Input("tHist","float32").Output("uint8").LoadChunk("pickValue").GLSLKernel("const float norm=1.0/(OUT_VIEW.x*OUT_VIEW.y);vec4 operation(float y,float x){vec4 histBase=pickValue_tSrc(y,x)*255.0;float r=pickValue_tHist(0.0,histBase.r).r;float g=pickValue_tHist(0.0,histBase.g).g;float b=pickValue_tHist(0.0,histBase.b).b;float a=pickValue_tHist(0.0,histBase.a).a;return vec4(r,g,b,255.0/norm)*norm;}").Compile({tSrc:t,tHist:e}))(t,(t=>new M("histogramCumulation").Input("tSrc","float32").Output("float32").LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 sum=vec4(0.0);for(float i=0.0;i<255.0;i+=1.0){vec4 value=pickValue_tSrc(0.0,i);if(i<=x){sum+=value;}else{break;}}return sum;}").Compile({tSrc:t}))(yt(t,e)));const kt=(t,e=10,a=0)=>{const n=~~(t.shape[0]/e),i=~~(t.shape[1]/e),r=Math.ceil(Math.max(t.shape[0]/n,t.shape[1]/i));return new M("ReduceMax").Input("tSrc",a?"float32":"uint8").Output("float32").Uniform("uF","float",a).LoadChunk("pickValue").Constant("W",r).Constant("H",r).Constant("O_WIDTH",t.shape[1]).Constant("O_HEIGHT",t.shape[0]).Constant("K",1/r).SetShapeFn((()=>[Math.ceil(t.shape[0]/r),Math.ceil(t.shape[1]/r),4])).GLSLKernel("const int w=int(W);const int h=int(H);vec4 operation(float _y,float _x){float mmax=0.0;float maxX=0.0;float maxY=0.0;float sy=_y*H;float sx=_x*W;float yLimit=O_HEIGHT-sy;float xLimit=O_WIDTH-sx;vec4 value;for(float y=0.0;y<H;y+=1.0){if(y>=yLimit){break;}for(float x=0.0;x<W;x+=1.0){if(x>=xLimit){break;}value=pickValue_tSrc(y+sy,x+sx);if(value.r>=mmax){mmax=value.r;if(uF<0.5){maxX=x+sx;maxY=y+sy;}else{maxX=value.g;maxY=value.b;}}}}return vec4(mmax,maxX,maxY,255.0);}").Compile({tSrc:t})};var Tt=(t,e=2,a=2,n=2)=>{let i=((t,e=3)=>{const a=Math.max(t.shape[0],t.shape[1]);return new M("PCLinesTransform").Input("tSrc","float32").Output("uint8").Uniform("uWidth","float",t.shape[1]).Uniform("uHeight","float",t.shape[0]).Constant("PI",Math.PI).Constant("D",a).Constant("STEP",e).Constant("MAX_DIST",a).Constant("MAX_ANGLE",a).LoadChunk("pickValue").SetShapeFn((()=>[a,a,4])).GLSLKernel("precision highp float;float intersectionX(vec4 line,float x){return((x-line.x)/(line.z-line.x)*(line.w-line.y)+line.y);}float intersectionY(vec4 line,float y){return((y-line.y)/(line.w-line.y)*(line.z-line.x)+line.x);}vec4 findSide(float x1,float y1,float x2,float y2){int i=0;vec2 i0=vec2(0,0);vec2 i1=vec2(0,0);float ax=0.0;float ay=intersectionY(vec4(x1,y1,x2,y2),ax);float by=0.0;float bx=intersectionX(vec4(x1,y1,x2,y2),by);float cx=MAX_DIST;float cy=intersectionY(vec4(x1,y1,x2,y2),cx);float dy=MAX_DIST;float dx=intersectionX(vec4(x1,y1,x2,y2),dy);if(ay<=MAX_DIST&&ay>=0.0){if(i==0){i0=vec2(ax,ay);i+=1;}}if(cy<=MAX_DIST&&cy>=0.0){if(i==0){i0=vec2(cx,cy);i+=1;}else{i1=vec2(cx,cy);}}if(bx<=MAX_DIST&&bx>=0.0){if(i==0){i0=vec2(bx,by);i+=1;}else{i1=vec2(bx,by);}}if(dx<=MAX_DIST&&dx>=0.0){if(i==0){i0=vec2(dx,dy);i+=1;}else{i1=vec2(dx,dy);}}return vec4(i0.x,i0.y,i1.x,i1.y);}float pow(float a){return a*a;}vec4 getStraight(float aIndex,float v,float dist,float angles){float y1;float y2;if(aIndex>angles){aIndex-=angles;y1=MAX_ANGLE-(angles*v/aIndex);y2=(-1.0+angles/aIndex)*uWidth+y1;}else{aIndex=angles-aIndex;y1=(angles*v/aIndex);y2=(1.0-angles/aIndex)*uWidth+y1;}return vec4(0.0,y1,uWidth,y2);}float getValue(float i,float lx,float ly,vec4 side){float xx=0.0;float yy=0.0;if(lx<ly){xx=i;yy=intersectionY(side,xx);}else{yy=i;xx=intersectionX(side,yy);}if(xx>0.0&&xx<uWidth&&yy>0.0&&yy<uHeight){float a=pickScalarValue_tSrc(floor(yy),floor(xx));if(a>0.0){return 1.0;}}return 0.0;}vec4 operation(float y,float x){float v_out=0.0;vec4 straight=getStraight(x,y,MAX_DIST,MAX_ANGLE/2.0);vec4 side=findSide(straight.x,straight.y,straight.z,straight.w);float lx=abs(side.z-side.x);float ly=abs(side.w-side.y);float k=1.0/D;for(float i=0.0;i<=D;i+=STEP){float a=getValue(i,lx,ly,side);if(a>0.0){v_out+=k;}}return vec4(v_out,v_out,v_out,255.0);}").Compile({tSrc:t})})(t,a);i=kt(i,n);for(let r=0;r<e;r+=1)i=kt(i,n,1);return i},Et=(t,e="rgb_to_hsv")=>{h("rgb_to_hsv"===e||"hsv_to_rgb"===e,`Unsupported type ${e}, currenlty avaliable: rgb_to_hsv, hsv_to_rgb.`);let a=null;return"rgb_to_hsv"===e&&(a="vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)),d/(q.x+e),q.x);}vec4 operation(float y,float x){return vec4(rgb2hsv(pickValue_tSrc(y,x).rgb),1);}"),"hsv_to_rgb"===e&&(a="vec3 hsv2rgb(vec3 c){vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);vec3 p=abs(fract(c.xxx+K.xyz)*6.0-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y);}vec4 operation(float y,float x){return vec4(hsv2rgb(pickValue_tSrc(y,x).rgb),1);}"),new M("HSV").Input("tSrc",t.dtype).Output(t.dtype).LoadChunk("pickValue").GLSLKernel(a).Compile({tSrc:t})},_t=(t,e=.5,a=0)=>(h("number"===typeof e,"Only number available as a threshold value."),h(0===a||1===a||2===a||3===a,"Only RGBA available: 0, 1, 2, 3"),new M("Threshold").Input("tSrc",t.dtype).Output(t.dtype).Constant("C",a).Uniform("uT","float",e).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 pixel=pickValue_tSrc(y,x);if(pixel[int(C)]>uT){return vec4(1.0,1.0,1.0,1.0);}else{return vec4(0.0,0.0,0.0,1.0);}}").Compile({tSrc:t})),Ct=(t,e=[2,2],a=!1)=>{if(h(2===e.length,"Erosion: Kernel size should be shape of rank 2"),g(a)&&h(e[0]===a.shape[0]&&e[1]===a.shape[1],"Erosion: Structure element has wrong size"),!a){a=new F("float32",[e[0],e[1],4]);for(let t=0;t<e[0];t+=1)for(let n=0;n<e[1];n+=1)a.set(t,n,0,1),a.set(t,n,1,1),a.set(t,n,2,1),a.set(t,n,3,1)}return new M("Erosion").Input("tSrc",t.dtype).Input("tKernel","float32").Output(t.dtype).Constant("KW",e[0]).Constant("KH",e[1]).LoadChunk("pickValue").GLSLKernel("float HKW=floor(KW/2.0);float HKH=floor(KW/2.0);vec4 operation(float y,float x){float R=10000.0;float G=10000.0;float B=10000.0;y=y+HKH;x=x+HKW;for(float dx=0.0;dx<KW;dx+=1.0){for(float dy=0.0;dy<KH;dy+=1.0){vec4 v=pickValue_tSrc((y-dy),(x-dx));vec4 m=pickValue_tKernel(dy,dx);if(v.r<R&&m.r>0.0){R=v.r;}if(v.g<G&&m.g>0.0){G=v.g;}if(v.b<B&&m.b>0.0){B=v.b;}}}return vec4(R,G,B,1.0);}").Compile({tSrc:t,tKernel:a})},It=(t,e=[2,2],a=!1)=>{if(h(2===e.length,"Dilation: Kernel size should be shape of rank 2"),g(a)&&h(e[0]===a.shape[0]&&e[1]===a.shape[1],"Dilation: Structure element has wrong size"),!a){a=new F("float32",[e[0],e[1],4]);for(let t=0;t<e[0];t+=1)for(let n=0;n<e[1];n+=1)a.set(t,n,0,1),a.set(t,n,1,1),a.set(t,n,2,1),a.set(t,n,3,1)}return new M("Dilation").Input("tSrc",t.dtype).Input("tKernel","float32").Output(t.dtype).Constant("KW",e[0]).Constant("KH",e[1]).LoadChunk("pickValue").GLSLKernel("float HKW=floor(KW/2.0);float HKH=floor(KW/2.0);vec4 operation(float y,float x){float R=0.0;float G=0.0;float B=0.0;y=y+HKH;x=x+HKW;for(float dx=0.0;dx<KW;dx+=1.0){for(float dy=0.0;dy<KH;dy+=1.0){vec4 v=pickValue_tSrc((y-dy),(x-dx));vec4 m=pickValue_tKernel(dy,dx);if(v.r>R&&m.r>0.0){R=v.r;}if(v.g>G&&m.g>0.0){G=v.g;}if(v.b>B&&m.b>0.0){B=v.b;}}}return vec4(R,G,B,1.0);}").Compile({tSrc:t,tKernel:a})};const At=(t,e,a)=>{h(g(e)||y(e),`${t}: A input is not a Tensor or Operation instance`),h(g(a)||y(a),`${t}: B input is not a Tensor or Operation instance`),h(e.dtype===a.dtype,`${t}: inputs should have the same dtype, got ${e.dtype} and ${a.dtype}`),h(e.shape[0]===a.shape[0]&&e.shape[1]===a.shape[1]&&e.shape[3]===a.shape[3],`${t}: inputs should have the same shapes, got ${e.shape} and ${a.shape}`)},wt=(t,e,a)=>{h("number"===typeof a,`${t}: scalar value is not a number`),h(g(e)||y(e),`${t}: A input is not a Tensor or Operation instance`)},Vt=(t,e)=>(At("Sub",t,e),new M("Sub").Input("tA",t).Input("tB",e).Output(t.dtype).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 A=pickValue_tA(y,x);vec4 B=pickValue_tB(y,x);return vec4(A.rgb-B.rgb,1.0);}").Compile({tA:t,tB:e})),Rt=(t,e)=>(At("Add",t,e),new M("Add").Input("tA",t).Input("tB",e).Output(t.dtype).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 A=pickValue_tA(y,x);vec4 B=pickValue_tB(y,x);return vec4(A.rgb+B.rgb,1.0);}").Compile({tA:t,tB:e})),Lt=(t,e)=>(At("Div",t,e),new M("Div").Input("tA",t).Input("tB",e).Output(t.dtype).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 A=pickValue_tA(y,x);vec4 B=pickValue_tB(y,x);return vec4(A.rgb/B.rgb,1.0);}").Compile({tA:t,tB:e})),Ot=(t,e)=>{const a="Mult";return At(a,t,e),new M(a).Input("tA",t).Input("tB",e).Output(t.dtype).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 A=pickValue_tA(y,x);vec4 B=pickValue_tB(y,x);return vec4(A.rgb*B.rgb,1.0);}").Compile({tA:t,tB:e})},Mt=(t,e)=>{const a="SubScalar";return wt(a,t,e),new M(a).Input("tA",t).Output(t.dtype).Uniform("uScalar","float",e).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 A=pickValue_tA(y,x);return vec4(A.rgb-uScalar,1.0);}").Compile({tA:t})},Ut=(t,e)=>{const a="AddScalar";return wt(a,t,e),new M(a).Input("tA",t).Output(t.dtype).Uniform("uScalar","float",e).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 A=pickValue_tA(y,x);return vec4(A.rgb+uScalar,1.0);}").Compile({tA:t})},Kt=(t,e)=>{const a="DivScalar";return wt(a,t,e),new M(a).Input("tA",t).Output(t.dtype).Uniform("uScalar","float",e).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 A=pickValue_tA(y,x);return vec4(A.rgb/uScalar,1.0);}").Compile({tA:t})},Pt=(t,e)=>{const a="MultScalar";return wt(a,t,e),new M(a).Input("tA",t).Output(t.dtype).Uniform("uScalar","float",e).LoadChunk("pickValue").GLSLKernel("vec4 operation(float y,float x){vec4 A=pickValue_tA(y,x);return vec4(A.rgb*uScalar,1.0);}").Compile({tA:t})};var Ft=(t,e="open",a=[2,2],n=!1)=>{switch(e){case"open":return It(Ct(t,a,n),a,n);case"close":return Ct(It(t,a,n),a,n);case"gradient":return Vt(It(t,a,n),Ct(t,a,n));case"tophat":return Vt(t,It(Ct(t,a,n),a,n));case"blackhat":return Vt(Ct(It(t,a,n),a,n),t);default:return new Error(`MorphTransform: unsopported operation type ${e}`)}},Gt=(t,e=2,a="nearest")=>{const n=~~(t.shape[1]*e),i=~~(t.shape[0]*e);return Q(t,n,i,a)};const Ht=(t,e="x",a=0,n=1)=>new M("SummedAreaTable").Input("tSrc",t.dtype).Output("float32").LoadChunk("pickValue").Constant("PASSI",a).Constant("LAST",!1).Constant("SAMPLES_PER_PASS",n).GLSLKernel("x"===e?"vec4 operation(float y,float x){vec4 res=pickValue_tSrc(y,x);for(float I=1.0;I<=SAMPLES_PER_PASS;I+=1.0){float cx=x-ceil(pow(1.0+SAMPLES_PER_PASS,PASSI)*I);if(cx<0.0){break;}res+=pickValue_tSrc(y,cx);}return res;}":"vec4 operation(float y,float x){vec4 res=pickValue_tSrc(y,x);for(float I=1.0;I<=SAMPLES_PER_PASS;I+=1.0){float cy=y-ceil(pow(1.0+SAMPLES_PER_PASS,PASSI)*I);if(cy<0.0){break;}res+=pickValue_tSrc(cy,x);}return res;}").Compile({tSrc:t}),Dt=(t,e=2,a=!1)=>{const n=Math.ceil(t.shape[1]**(1/e)),i=Math.ceil(t.shape[0]**(1/e));let r=t;const o=Math.log(t.shape[1])/Math.log(Math.max(n+1,2)),s=Math.log(t.shape[0])/Math.log(Math.max(i+1,2));a&&(r=((t,e=0,a=1)=>new M("SquaredSummedAreaTable").Input("tSrc",t.dtype).Output("float32").LoadChunk("pickValue").Constant("PASSI",e).Constant("LAST",!1).Constant("SAMPLES_PER_PASS",a).GLSLKernel("vec4 operation(float y,float x){vec4 res=pickValue_tSrc(y,x);res=res*res;vec4 v=vec4(0.0);for(float I=1.0;I<=SAMPLES_PER_PASS;I+=1.0){float cx=x-ceil(pow(1.0+SAMPLES_PER_PASS,PASSI)*I);if(cx<0.0){break;}v=pickValue_tSrc(y,cx);res+=v*v;}return res;}").Compile({tSrc:t}))(r,0,Math.min(n,t.shape[1]-1)));for(let l=a?1:0;l<o;l+=1)r=Ht(r,"x",l,Math.min(n,t.shape[1]-1));for(let l=0;l<s;l+=1)r=Ht(r,"y",l,Math.min(i,t.shape[0]-1));return r},$t=(t,e=2)=>Dt(t,e,!1),Bt=(t,e=2)=>Dt(t,e,!0);var Xt=(t,e=5,a=50,n=0,i=$t(t))=>(h("number"===typeof a,"Only number available as a threshold value."),h("number"===typeof e,"Only number available as a size value."),h(0===n||1===n||2===n||3===n,"Only RGBA available: 0, 1, 2, 3"),new M("Threshold").Input("tSrc",t.dtype).Input("tIntegralImage",i.dtype).Output(t.dtype).Constant("C",n).Uniform("uS","float",e).Uniform("uT","float",a).LoadChunk("pickValue").GLSLKernel("const int Channel=int(C);float pickValue(float y,float x){if(y<0.0||x<0.0){return 0.0;}return pickValue_tIntegralImage(y,x)[Channel];}vec4 operation(float y,float x){vec4 pixel=pickValue_tSrc(y,x);float huS=uS/2.0;vec2 p1=max(floor(vec2(x,y)-huS),vec2(0.0));vec2 p2=min(floor(vec2(x,y)+huS),OUT_VIEW-1.0);vec2 pd=p2+1.0-p1;float s=pd.x*pd.y;p1-=1.0;float sum=pickValue(p2.y,p2.x)-pickValue(p1.y,p2.x)-pickValue(p2.y,p1.x)+pickValue(p1.y,p1.x);if(pixel[Channel]*s<=sum*(100.0-uT)/100.0){return vec4(0.0,0.0,0.0,1.0);}else{return vec4(1.0,1.0,1.0,1.0);}}").Compile({tSrc:t,tIntegralImage:i}));function Wt(t,e,a){return t-1e-7<=e&&e<=a+1e-7}class Nt{static Intersection(t,e){const a=t.x1,n=t.y1,i=t.x2,r=t.y2,o=e.x1,s=e.y1,l=e.x2,c=e.y2,u=((a*r-n*i)*(o-l)-(a-i)*(o*c-s*l))/((a-i)*(s-c)-(n-r)*(o-l)),h=((a*r-n*i)*(s-c)-(n-r)*(o*c-s*l))/((a-i)*(s-c)-(n-r)*(o-l));if(isNaN(u)||isNaN(h))return!1;if(a>=i){if(!Wt(i,u,a))return!1}else if(!Wt(a,u,i))return!1;if(n>=r){if(!Wt(r,h,n))return!1}else if(!Wt(n,h,r))return!1;if(o>=l){if(!Wt(l,u,o))return!1}else if(!Wt(o,u,l))return!1;if(s>=c){if(!Wt(c,h,s))return!1}else if(!Wt(s,h,c))return!1;return[u,h]}constructor(t,e,a,n,i,r){if(t instanceof ArrayBuffer)this.data=new Float32Array(t,e,8);else if(Array.isArray(t)){if(t.length<8)for(let e=t.length;e<=8;e+=1)t.push(0);this.data=new Float32Array(t)}else this.data=void 0!==t&&void 0!==e?new Float32Array([t,e,a,n,i,r,0,0]):new Float32Array(8)}set(t,e,a,n,i,r){this.data[0]=t,this.data[1]=e,this.data[2]=a,this.data[3]=n,this.data[4]=i,this.data[5]=r,this.data[6]=0,this.data[7]=0}fromParallelCoords(t,e,a,n,i,r){const o=a;let s,l;t>r?(s=i-r*e/(t-=r),l=(r/t-1)*a+s):(s=r*e/(t=r-t),l=(1-r/t)*a+s),this.set(0,s,o,l,t,e)}get length(){if(this.data[6])return this.data[6];const t=this.data[2]-this.data[0],e=this.data[3]-this.data[1],a=Math.sqrt(t**2+e**2);return this.data[6]=a,a}get angle(){if(this.data[7])return this.data[7];const t=this.data[2]-this.data[0],e=this.data[3]-this.data[1];let a=Math.atan(e/t)/Math.PI*180;return a<0&&(a=180+a),this.data[7]=a,a}get x1(){return this.data[0]}get y1(){return this.data[1]}get x2(){return this.data[2]}get y2(){return this.data[3]}get px(){return this.data[4]}get py(){return this.data[5]}set x1(t){this.data[0]=t}set y1(t){this.data[1]=t}set x2(t){this.data[2]=t}set y2(t){this.data[3]=t}set px(t){this.data[4]=t}set py(t){this.data[5]=t}clear(){this.data[0]=0,this.data[1]=0,this.data[2]=0,this.data[3]=0,this.data[4]=0,this.data[5]=0,this.data[6]=0,this.data[7]=0}fromArray(t){this.data.set(t)}toArray(){return Array.prototype.slice.call(this.data)}}function zt(t,e){const a=t[2]-t[0],n=t[3]-t[1],i=e[2]-e[0],r=e[3]-e[1],o=a*i+n*r,s=(a*a+n*n)*(i*i+r*r);return Math.acos(o/Math.sqrt(s))}function jt(t,e,a){const n=a;let i=0,r=0,o=0,s=0,l=0,c=0;return o=n.get(0,1)*e+n.get(0,2),s=n.get(1,1)*e+n.get(1,2),l=n.get(2,1)*e+n.get(2,2),o+=n.get(0,0)*t,s+=n.get(1,0)*t,l+=n.get(2,0)*t,c=1/l,i=o*c,r=s*c,[i,r]}Nt.BYTES_PER_ELEMENT=36;class Yt{static Distance(t,e){let a=0;for(let n=0;n<8;n+=2){a+=Math.sqrt((t.data[n]-e.data[n])**2+(t.data[n+1]-e.data[n+1])**2)**2}return a=Math.sqrt(a/8),a===1/0?0:a}static TriangleS(t,e,a,n,i,r){return Math.abs(t*(n-r)+a*(r-e)+i*(e-n))/2}constructor(...t){t[0]instanceof ArrayBuffer?this.data=new Float32Array(t[0],t[1],Yt.NUM_ELEMENTS):Array.isArray(t[0])?this.data=new Float32Array(t[0]):t[0]&&t.length===Yt.NUM_ELEMENTS?this.data=new Float32Array(t):this.data=new Float32Array(Yt.NUM_ELEMENTS)}isInRect(t,e){return!(Yt.TriangleS(t,e,this.ax,this.ay,this.bx,this.by)+Yt.TriangleS(t,e,this.cx,this.cy,this.bx,this.by)+Yt.TriangleS(this.cx,this.cy,t,e,this.dx,this.dy)+Yt.TriangleS(this.dx,this.dy,t,e,this.ax,this.ay)-this.area>0)}isNotEmpty(){return this.data[0]>0&&this.data[1]>0&&this.data[2]>0&&this.data[3]>0&&this.data[4]>0&&this.data[5]>0&&this.data[6]>0&&this.data[7]>0}clone(){return new Yt(this.toArray())}set(t,e,a,n,i,r,o,s){this.data[0]=t,this.data[1]=e,this.data[2]=a,this.data[3]=n,this.data[4]=i,this.data[5]=r,this.data[6]=o,this.data[7]=s}assign(t){return this.data.set(t.data),this}scale(t,e){return this.data[0]*=t,this.data[1]*=e,this.data[2]*=t,this.data[3]*=e,this.data[4]*=t,this.data[5]*=e,this.data[6]*=t,this.data[7]*=e,this}fromLines(t,e,a,n){const i=function(t,e){const a=[0,0];let n=null,i=null,r=null,o=null;a[0]+=t[0][0],a[0]+=t[1][0],a[0]+=t[2][0],a[0]+=t[3][0],a[1]+=t[0][1],a[1]+=t[1][1],a[1]+=t[2][1],a[1]+=t[3][1],a[0]/=4,a[1]/=4;for(let s=0;s<t.length;s+=1)t[s][0]>=a[0]&&t[s][1]>=a[1]&&(r=t[s]),t[s][0]<=a[0]&&t[s][1]<=a[1]&&(n=t[s]),t[s][0]>=a[0]&&t[s][1]<=a[1]&&(i=t[s]),t[s][0]<=a[0]&&t[s][1]>=a[1]&&(o=t[s]);return[n,i,r,o]}([Nt.Intersection(t,e),Nt.Intersection(e,a),Nt.Intersection(a,n),Nt.Intersection(n,t)]);return!!(i[0]&&i[1]&&i[2]&&i[3])&&(this.data[0]=i[0][0],this.data[1]=i[0][1],this.data[2]=i[1][0],this.data[3]=i[1][1],this.data[4]=i[2][0],this.data[5]=i[2][1],this.data[6]=i[3][0],this.data[7]=i[3][1],!0)}get ax(){return this.data[0]}get ay(){return this.data[1]}get bx(){return this.data[2]}get by(){return this.data[3]}get cx(){return this.data[4]}get cy(){return this.data[5]}get dx(){return this.data[6]}get dy(){return this.data[7]}set ax(t){this.data[0]=t}set ay(t){this.data[1]=t}set bx(t){this.data[2]=t}set by(t){this.data[3]=t}set cx(t){this.data[4]=t}set cy(t){this.data[5]=t}set dx(t){this.data[6]=t}set dy(t){this.data[7]=t}get distA(){return Math.sqrt((this.data[6]-this.data[0])**2+(this.data[7]-this.data[1])**2)}get distB(){return Math.sqrt((this.data[4]-this.data[2])**2+(this.data[5]-this.data[3])**2)}get distC(){return Math.sqrt((this.data[0]-this.data[2])**2+(this.data[1]-this.data[3])**2)}get distD(){return Math.sqrt((this.data[6]-this.data[4])**2+(this.data[7]-this.data[5])**2)}get distE(){return Math.sqrt((this.data[0]-this.data[4])**2+(this.data[1]-this.data[5])**2)}get distF(){return Math.sqrt((this.data[6]-this.data[2])**2+(this.data[7]-this.data[3])**2)}get angleA(){return zt([this.data[6],this.data[7],this.data[0],this.data[1]],[this.data[0],this.data[1],this.data[2],this.data[3]])}get angleB(){return zt([this.data[0],this.data[1],this.data[2],this.data[3]],[this.data[2],this.data[3],this.data[4],this.data[5]])}get angleC(){return zt([this.data[2],this.data[3],this.data[4],this.data[5]],[this.data[4],this.data[5],this.data[6],this.data[7]])}get angleD(){return zt([this.data[4],this.data[5],this.data[6],this.data[7]],[this.data[6],this.data[7],this.data[0],this.data[1]])}get area(){const t=this.distA,e=this.distB,a=this.distC,n=this.distD,i=(t+e+a+n)/2;return Math.sqrt((i-t)*(i-e)*(i-a)*(i-n))}get P(){return this.distA+this.distB+this.distC+this.distD}mul(t){return this.data[0]*=t,this.data[1]*=t,this.data[2]*=t,this.data[3]*=t,this.data[4]*=t,this.data[5]*=t,this.data[6]*=t,this.data[7]*=t,this}scaleAt(t){return this.data[0]-=t,this.data[1]-=t,this.data[2]-=t,this.data[3]+=t,this.data[4]+=t,this.data[5]+=t,this.data[6]+=t,this.data[7]-=t,this}clear(){this.data[0]=0,this.data[1]=0,this.data[2]=0,this.data[3]=0,this.data[4]=0,this.data[5]=0,this.data[6]=0,this.data[7]=0}fromDeep(t){return this.data[0]=t[0][0],this.data[1]=t[0][1],this.data[2]=t[1][0],this.data[3]=t[1][1],this.data[4]=t[2][0],this.data[5]=t[2][1],this.data[6]=t[3][0],this.data[7]=t[3][1],this}perspective(t){const e=jt(this.data[0],this.data[1],t),a=jt(this.data[2],this.data[3],t),n=jt(this.data[4],this.data[5],t),i=jt(this.data[6],this.data[7],t);return this.data[0]=e[0],this.data[1]=e[1],this.data[2]=a[0],this.data[3]=a[1],this.data[4]=n[0],this.data[5]=n[1],this.data[6]=i[0],this.data[7]=i[1],this}fromArray(t){return this.data.set(t),this}toArray(){return Array.prototype.slice.call(this.data)}isInside(t){return t.ax>this.ax&&t.ay>this.ay&&t.bx<this.bx&&t.by>this.by&&t.cx<this.cx&&t.cy<this.cy&&t.dx>this.dx&&t.dy<this.dy}toJSON(){return this.toArray()}}Yt.NUM_ELEMENTS=8,Yt.BYTES_PER_ELEMENT=Yt.NUM_ELEMENTS*Float32Array.BYTES_PER_ELEMENT}}]);
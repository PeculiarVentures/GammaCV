{"pageProps":{"id":"create_operation","data":"# Create Operation\n\nWhen building graphs using `GammaCV`, you may want to create a new `Operation`. This article will describe how to create your own `Operation`.\n\n## Prerequisites\nThis document assumes familiarity with the fundamentals of GammaCV introduced in the Core Concepts section of [Getting Started](/docs/get_started). We recommend completing Core Concepts before reading this tutorial.\n\n## Name operation\nTo create a shell your operation, you simply need to use `RegisterOperation`\n\n```js\nimport * as gm from 'gammacv';\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n```\n\n## Describe inputs and output\n### Inputs\nYou can append input using ```.Input(name <string>, dtype <string>)```\n\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('src', 'uint8')\n```\nThis code appends input named src and described it as unsigned byte datatype.\nAt this milestone, we support only `uint8` and `float32` input datatypes.\nEach `RegisterOperation` instance method returns itself, so you can pipe multiple inputs.\nIt is very usefull for future steps to name inputs starting with `t`, like \"src\" -> \"tSrc\".\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Input('tMask', 'float32')\n```\n\n### Output\nYou should describe the output datatype using `.Output(dtype <string>)`, and output shape using `.SetShapeFn(cb <function>)`.\nAt this milestone, we support only `uint8` and `float32` output datatypes and only shapes that matched `[n, m, 4]`.\nBy default output datatype and shape are the same as in first input.\nYou can specify Output just once for one operation.\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Input('tMask', 'float32')\n  .Output('uint8')\n  .SetShapeFn(() => [20, 15, 4])\n```\n\nIn this way, you described that your operation receives two inputs and specify their names and datatypes, and the output will be Tensor('uint8', [20, 15, 4]).\n\n## Describe variables and constants\nYou may want to have some variables or constants other than the input data.\n`.Constant(name <string>, value <string|number>)` - will create a constant that can't be change once operation was compiled.\n`.Uniform(name <string>, type <string>, value <string|number>)` - will create a variable which you can change between operation executing, supported types are:\n```js\n'bool', 'int', 'uint',\n'float', 'double',\n'vec2', 'vec3', 'vec4',\n'mat2', 'mat3', 'mat4'\n```\n\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Input('tMask', 'float32')\n  .Output('uint8')\n  .SetShapeFn(() => [20, 15, 4])\n  .Constant('TRESHOLD', 0.5)\n  .Uniform('uMultiplier', 'float', 0.5)\n```\n\n## Write WebGL backend\nYou can write your WebGL backend as a string or as a separate file and load it via network request or your module bundler. This named as operation kernel.\n[WebGL](https://en.wikipedia.org/wiki/WebGL) backend should be written using [GLSL (OpenGL Shading Language)](https://en.wikipedia.org/wiki/OpenGL_Shading_Language). You should use [OpenGL ES 2.0](https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_2.0) standard to be compatible with devices that support only WebGL 1.0, and you can use [OpenGL ES 3.0](https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_3.0) for devices compatible with WebGL 2.0.\n\nYou shouldn't use `void main` in kernel code!\nThe entry point for your code is `vec4 operation(float y, float x)` that should be defined.\nThis entry point will be called for each output component of operation and receives coordinate of this component as float arguments and should return a 4-component vector of the output value.\n\n```glsl\nvec4 operation(float y, float x) {\n  return vec4(0.0);\n}\n```\nThis code will fill output with zeros.\n\n### Use constants and uniforms\nInside your glsl kernel you can use constants defined with RegisterOperation, just type the name of constant or variable, be careful and check the types of your variables.\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() => [20, 15, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n```\n```glsl\nvec4 operation(float y, float x) {\n  return vec4(y * uMultiplier, x * uMultiplier, TRESHOLD, TRESHOLD);\n}\n```\n\n### GLSL Chunks\nThe full documentation for GLSL Chunks, you can find [here](/docs/glsl_chunks)\nIf you want to get inputs data inside your kernel, you should use pre-defined glsl-chunks, and specify it's loading in RegisterOperation pipe:\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() => [20, 15, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n  .LoadChunk('pickValue')\n```\nThen you can use it in glsl code\n```glsl\nvec4 operation(float y, float x) {\n  return pickValue_tSrc(y, x) * pickValue_tSrc(y, x);\n}\n```\n\n### Append backend to operation\nYou should use `.GLSLKernel(kernel <string>)` for this.\n```js\nimport kernel from './kernel.glsl';\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() => [20, 15, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel)\n```\n\n## Provide inputs and compile\nTo prepare your operation for a run, you should compile it with providing input tensors:\n`.Compile(inputs <Object>)`, where inputs object has keys named same as operation's input and contain tensor or operation as values\n\n```js\nconst tSrc = new gm.Tensor('uint8', [2, 2, 4]);\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() => [1, 1, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel)\n  .Compile({ tSrc })\n```\nThis method returns `Operation` instance that is ready to provide into `Session`.\n\n## Example\n\nindex.js\n```js\nimport * as gm from 'gammacv';\nimport kernel from './kernel.glsl';\n\nconst tSrc = new gm.Tensor('uint8', [2, 2, 4], new Uint8Array([\n  200, 2, 3, 34,  5, 6, 7, 125,\n  9, 6, 7, 0,     3, 4, 5, 0,\n]));\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() => [1, 1, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.5)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel)\n  .Compile({ tSrc })\n```\n\nkernel.glsl\n```glsl\n// will be called just once since the output is only one pixel\n// y and x will be 0.0\nvec4 operation(float y, float x) {\n  vec4 data = pickValue_tSrc(y, x);\n  // data will have value around vec4(0.78, 0.0078, 0.011, 0.13)\n  // since uint values are viewed as floats 0..1 that describes (0..255)\n\n  return vec4(data.r * uMultiplier, FILL, FILL, FILL);\n  // will return around vec4(0.78 * 0.5 = 0.39, 1.0, 1.0, 1.0)\n  // that will be viewed in uint8 as vec4(100, 255, 255, 255).`\n}\n```\n\nRunning this operation will output tensor with next data: [100, 255, 255, 255].\n"},"__N_SSG":true}
<!DOCTYPE html><html lang="en"><head><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&amp;display=swap" rel="stylesheet"/><link rel="stylesheet" href="/static/theme.css"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"/><meta name="description" content="GammaCV is a WebGL accelerated Computer Vision library for modern web applications."/><meta name="Keywords" content="computer vision, WebGL, javascript"/><meta property="og:title" content="GammaCV"/><meta property="og:description" content="GammaCV is a WebGL accelerated Computer Vision library for modern web applications."/><meta property="og:image" content="https://gammacv.com/static/images/share_image.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:description" content="GammaCV is a WebGL accelerated Computer Vision library for modern web applications."/><meta name="twitter:image" content="https://gammacv.com/static/images/share_image.png"/><link rel="icon" href="/static/manifest/favicon.ico"/><link rel="apple-touch-icon" href="/static/manifest/apple-touch-icon.png"/><link rel="manifest" href="/static/manifest/manifest.webmanifest"/><noscript>You need to enable JavaScript to run this app.</noscript><title>Create Operation - GammaCV</title><meta name="twitter:title" content="Create Operation - GammaCV"/><meta property="og:title" content="Create Operation - GammaCV"/><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/5ca4173648ae50e38809.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5ca4173648ae50e38809.css" data-n-g=""/><link rel="preload" href="/_next/static/css/28d7647de2a1cd417806.css" as="style"/><link rel="stylesheet" href="/_next/static/css/28d7647de2a1cd417806.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-7899de15d31abfcf2ba1.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-a254bdb28f684739f8fb.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons-bd991d3914d6d42e2a9c.js" as="script"/><link rel="preload" href="/_next/static/chunks/433-cd3d6a81c7946c739a1f.js" as="script"/><link rel="preload" href="/_next/static/chunks/778-ca9322c2990db1f6c421.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-5ec178cac14bcca48b45.js" as="script"/><link rel="preload" href="/_next/static/chunks/215-2125f971840a78b996f6.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-23d28ef32fbe15e5719d.js" as="script"/><link rel="preload" href="/_next/static/chunks/422-4193e727ae41a09dbc80.js" as="script"/><link rel="preload" href="/_next/static/chunks/933-12f2e0948a4af74f41d8.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/docs/%5Bid%5D-139ef8803532d7f6f7b6.js" as="script"/></head><body><div id="__next"><header class="header_root__32JNr header_m_not_main__LLfSy" style="background-color:rgba(var(--black), 1)"><a class="header_logo__1I1V9" href="/"><img src="/static/images/logo.svg" alt="GammaCV Logo"/></a><div class="header_spacer__25x4X"></div><a class="header_nav_item__3EXg6 text_white b2" href="/docs/get_started">Docs</a><a class="header_nav_item__3EXg6 text_white b2" href="/examples">Examples</a><a href="https://github.com/PeculiarVentures/GammaCV" target="_blank" rel="noopener noreferrer" class="header_nav_item__3EXg6 text_white b2">GitHub</a></header><nav class="sidebar_root__OWLV-" style="visibility:visible;background-color:rgba(var(--light_grey), 0.5);border-color:rgba(var(--grey), 0.15);border-width:0px 1px 0px 0px;border-style:solid"><div class="sidebar_header__227Nm"><label data-component="text_field" data-disabled="false" class="text_field sidebar_search_field__3FgHE"><div data-component="input" data-type="fill" data-disabled="false" class="input"><input type="text" class="input_field round_small input_field_medium stroke_light_grey input_field_focus_primary fill_light_grey text_black input_placeholder_color_grey_4" tabindex="0" placeholder="Search" aria-invalid="false"/></div></label></div><ul class="sidebar_list__3_4l5"><li class="sidebar_group_root__3ZpWz"><p data-component="typography" class="break_word text_grey text_left sidebar_group_group_name__2mZWj c1">Basics</p><ul class="sidebar_group_list__1exNa"><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/get_started">Get Started</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/create_operation">Create Operation</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/contributing">Contributing</a></li></ul></li><li class="sidebar_group_root__3ZpWz"><p data-component="typography" class="break_word text_grey text_left sidebar_group_group_name__2mZWj c1">Api</p><ul class="sidebar_group_list__1exNa"><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/tensor">Tensor</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/session">Session</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/glsl_chunks">GLSL Chunks</a></li></ul></li><li class="sidebar_group_root__3ZpWz"><p data-component="typography" class="break_word text_grey text_left sidebar_group_group_name__2mZWj c1">Image processing</p><ul class="sidebar_group_list__1exNa"><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/downsample">Downsample</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/upsample">Upsample</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/resize">Resize</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/gaussian_blur">Gaussian Blur</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/grayscale">Grayscale</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/norm">Normalization</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/color_segmentation">Color Segmentation</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/hsv_color">HSV Color Converter</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/threshold">Threshold</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/adaptive_threshold">Adaptive Threshold</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/conv2d">Convolution</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/sat">Summed Area Table</a></li></ul></li><li class="sidebar_group_root__3ZpWz"><p data-component="typography" class="break_word text_grey text_left sidebar_group_group_name__2mZWj c1">Morphology</p><ul class="sidebar_group_list__1exNa"><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/erode">Erosion</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/dilate">Dilation</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/morphology_ex">Extended Morphology</a></li></ul></li><li class="sidebar_group_root__3ZpWz"><p data-component="typography" class="break_word text_grey text_left sidebar_group_group_name__2mZWj c1">Image derivative</p><ul class="sidebar_group_list__1exNa"><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/sobel_operator">Sobel Operator</a></li></ul></li><li class="sidebar_group_root__3ZpWz"><p data-component="typography" class="break_word text_grey text_left sidebar_group_group_name__2mZWj c1">Feature extraction</p><ul class="sidebar_group_list__1exNa"><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/hog">Hog</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/canny_edges">Canny Edges</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/skin_test">Skin Test</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/motion_detect">MotionDetect</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/swt">StrokeWidthTransform</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/pclines">PCLinesTransform</a></li></ul></li><li class="sidebar_group_root__3ZpWz"><p data-component="typography" class="break_word text_grey text_left sidebar_group_group_name__2mZWj c1">Utils</p><ul class="sidebar_group_list__1exNa"><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/mean_std">MeanStd</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/minmax">MinMax</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/sliding_window">SlidingWindow</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/concat">Concat</a></li><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/cast">Cast</a></li></ul></li><li class="sidebar_group_root__3ZpWz"><p data-component="typography" class="break_word text_grey text_left sidebar_group_group_name__2mZWj c1">Math</p><ul class="sidebar_group_list__1exNa"><li><a class="sidebar_group_link__2t63M b2 text_black" href="/docs/math">Basic</a></li></ul></li></ul></nav><main class="docs_main__22h6B"><div class="docs_m_width__2I3Hm"><div class="docs_doc__LPaiP b1 text_black"><h1><a class="docs_anchor_link__3W_rr" id="CreateOperation"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#CreateOperation"><img src="/static/images/anchor.svg"/></a>Create Operation</h1><p>When building graphs using <code class="fill_light_grey docs_doc_code__1U1Vz">GammaCV</code>, you may want to create a new <code class="fill_light_grey docs_doc_code__1U1Vz">Operation</code>. This article will describe how to create your own <code class="fill_light_grey docs_doc_code__1U1Vz">Operation</code>.</p><h2><a class="docs_anchor_link__3W_rr" id="Prerequisites"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#Prerequisites"><img src="/static/images/anchor.svg"/></a>Prerequisites</h2><p>This document assumes familiarity with the fundamentals of GammaCV introduced in the Core Concepts section of <a class="text_primary" href="/docs/get_started">Getting Started</a>. We recommend completing Core Concepts before reading this tutorial.</p><h2><a class="docs_anchor_link__3W_rr" id="Nameoperation"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#Nameoperation"><img src="/static/images/anchor.svg"/></a>Name operation</h2><p>To create a shell your operation, you simply need to use <code class="fill_light_grey docs_doc_code__1U1Vz">RegisterOperation</code></p><pre data-component="highlight_code" class="language-js"><code class="language-js">import * as gm from &#x27;gammacv&#x27;;

const myOperation = new gm.RegisterOperation(&#x27;MyOp&#x27;)</code></pre><h2><a class="docs_anchor_link__3W_rr" id="Describeinputsandoutput"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#Describeinputsandoutput"><img src="/static/images/anchor.svg"/></a>Describe inputs and output</h2><h3><a class="docs_anchor_link__3W_rr" id="Inputs"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#Inputs"><img src="/static/images/anchor.svg"/></a>Inputs</h3><p>You can append input using <code class="fill_light_grey docs_doc_code__1U1Vz">.Input(name &lt;string&gt;, dtype &lt;string&gt;)</code></p><pre data-component="highlight_code" class="language-js"><code class="language-js">const myOperation = new gm.RegisterOperation(&#x27;MyOp&#x27;)
  .Input(&#x27;src&#x27;, &#x27;uint8&#x27;)</code></pre><p>This code appends input named src and described it as unsigned byte datatype.
At this milestone, we support only <code class="fill_light_grey docs_doc_code__1U1Vz">uint8</code> and <code class="fill_light_grey docs_doc_code__1U1Vz">float32</code> input datatypes.
Each <code class="fill_light_grey docs_doc_code__1U1Vz">RegisterOperation</code> instance method returns itself, so you can pipe multiple inputs.
It is very usefull for future steps to name inputs starting with <code class="fill_light_grey docs_doc_code__1U1Vz">t</code>, like &quot;src&quot; -&gt; &quot;tSrc&quot;.</p><pre data-component="highlight_code" class="language-js"><code class="language-js">const myOperation = new gm.RegisterOperation(&#x27;MyOp&#x27;)
  .Input(&#x27;tSrc&#x27;, &#x27;uint8&#x27;)
  .Input(&#x27;tMask&#x27;, &#x27;float32&#x27;)</code></pre><h3><a class="docs_anchor_link__3W_rr" id="Output"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#Output"><img src="/static/images/anchor.svg"/></a>Output</h3><p>You should describe the output datatype using <code class="fill_light_grey docs_doc_code__1U1Vz">.Output(dtype &lt;string&gt;)</code>, and output shape using <code class="fill_light_grey docs_doc_code__1U1Vz">.SetShapeFn(cb &lt;function&gt;)</code>.
At this milestone, we support only <code class="fill_light_grey docs_doc_code__1U1Vz">uint8</code> and <code class="fill_light_grey docs_doc_code__1U1Vz">float32</code> output datatypes and only shapes that matched <code class="fill_light_grey docs_doc_code__1U1Vz">[n, m, 4]</code>.
By default output datatype and shape are the same as in first input.
You can specify Output just once for one operation.</p><pre data-component="highlight_code" class="language-js"><code class="language-js">const myOperation = new gm.RegisterOperation(&#x27;MyOp&#x27;)
  .Input(&#x27;tSrc&#x27;, &#x27;uint8&#x27;)
  .Input(&#x27;tMask&#x27;, &#x27;float32&#x27;)
  .Output(&#x27;uint8&#x27;)
  .SetShapeFn(() =&gt; [20, 15, 4])</code></pre><p>In this way, you described that your operation receives two inputs and specify their names and datatypes, and the output will be Tensor(&#x27;uint8&#x27;, [20, 15, 4]).</p><h2><a class="docs_anchor_link__3W_rr" id="Describevariablesandconstants"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#Describevariablesandconstants"><img src="/static/images/anchor.svg"/></a>Describe variables and constants</h2><p>You may want to have some variables or constants other than the input data.
<code class="fill_light_grey docs_doc_code__1U1Vz">.Constant(name &lt;string&gt;, value &lt;string|number&gt;)</code> - will create a constant that can&#x27;t be change once operation was compiled.
<code class="fill_light_grey docs_doc_code__1U1Vz">.Uniform(name &lt;string&gt;, type &lt;string&gt;, value &lt;string|number&gt;)</code> - will create a variable which you can change between operation executing, supported types are:</p><pre data-component="highlight_code" class="language-js"><code class="language-js">&#x27;bool&#x27;, &#x27;int&#x27;, &#x27;uint&#x27;,
&#x27;float&#x27;, &#x27;double&#x27;,
&#x27;vec2&#x27;, &#x27;vec3&#x27;, &#x27;vec4&#x27;,
&#x27;mat2&#x27;, &#x27;mat3&#x27;, &#x27;mat4&#x27;</code></pre><pre data-component="highlight_code" class="language-js"><code class="language-js">const myOperation = new gm.RegisterOperation(&#x27;MyOp&#x27;)
  .Input(&#x27;tSrc&#x27;, &#x27;uint8&#x27;)
  .Input(&#x27;tMask&#x27;, &#x27;float32&#x27;)
  .Output(&#x27;uint8&#x27;)
  .SetShapeFn(() =&gt; [20, 15, 4])
  .Constant(&#x27;TRESHOLD&#x27;, 0.5)
  .Uniform(&#x27;uMultiplier&#x27;, &#x27;float&#x27;, 0.5)</code></pre><h2><a class="docs_anchor_link__3W_rr" id="WriteWebGLbackend"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#WriteWebGLbackend"><img src="/static/images/anchor.svg"/></a>Write WebGL backend</h2><p>You can write your WebGL backend as a string or as a separate file and load it via network request or your module bundler. This named as operation kernel.
<a class="text_primary" href="https://en.wikipedia.org/wiki/WebGL">WebGL</a> backend should be written using <a class="text_primary" href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL (OpenGL Shading Language)</a>. You should use <a class="text_primary" href="https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_2.0">OpenGL ES 2.0</a> standard to be compatible with devices that support only WebGL 1.0, and you can use <a class="text_primary" href="https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_3.0">OpenGL ES 3.0</a> for devices compatible with WebGL 2.0.</p><p>You shouldn&#x27;t use <code class="fill_light_grey docs_doc_code__1U1Vz">void main</code> in kernel code!
The entry point for your code is <code class="fill_light_grey docs_doc_code__1U1Vz">vec4 operation(float y, float x)</code> that should be defined.
This entry point will be called for each output component of operation and receives coordinate of this component as float arguments and should return a 4-component vector of the output value.</p><pre data-component="highlight_code" class="language-glsl"><code class="language-glsl">vec4 operation(float y, float x) {
  return vec4(0.0);
}</code></pre><p>This code will fill output with zeros.</p><h3><a class="docs_anchor_link__3W_rr" id="Useconstantsanduniforms"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#Useconstantsanduniforms"><img src="/static/images/anchor.svg"/></a>Use constants and uniforms</h3><p>Inside your glsl kernel you can use constants defined with RegisterOperation, just type the name of constant or variable, be careful and check the types of your variables.</p><pre data-component="highlight_code" class="language-js"><code class="language-js">const myOperation = new gm.RegisterOperation(&#x27;MyOp&#x27;)
  .Input(&#x27;tSrc&#x27;, &#x27;uint8&#x27;)
  .Output(&#x27;uint8&#x27;)
  .SetShapeFn(() =&gt; [20, 15, 4])
  .Constant(&#x27;FILL&#x27;, 1.0)
  .Uniform(&#x27;uMultiplier&#x27;, &#x27;float&#x27;, 0.3)</code></pre><pre data-component="highlight_code" class="language-glsl"><code class="language-glsl">vec4 operation(float y, float x) {
  return vec4(y * uMultiplier, x * uMultiplier, TRESHOLD, TRESHOLD);
}</code></pre><h3><a class="docs_anchor_link__3W_rr" id="GLSLChunks"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#GLSLChunks"><img src="/static/images/anchor.svg"/></a>GLSL Chunks</h3><p>The full documentation for GLSL Chunks, you can find <a class="text_primary" href="/docs/glsl_chunks">here</a>
If you want to get inputs data inside your kernel, you should use pre-defined glsl-chunks, and specify it&#x27;s loading in RegisterOperation pipe:</p><pre data-component="highlight_code" class="language-js"><code class="language-js">const myOperation = new gm.RegisterOperation(&#x27;MyOp&#x27;)
  .Input(&#x27;tSrc&#x27;, &#x27;uint8&#x27;)
  .Output(&#x27;uint8&#x27;)
  .SetShapeFn(() =&gt; [20, 15, 4])
  .Constant(&#x27;FILL&#x27;, 1.0)
  .Uniform(&#x27;uMultiplier&#x27;, &#x27;float&#x27;, 0.3)
  .LoadChunk(&#x27;pickValue&#x27;)</code></pre><p>Then you can use it in glsl code</p><pre data-component="highlight_code" class="language-glsl"><code class="language-glsl">vec4 operation(float y, float x) {
  return pickValue_tSrc(y, x) * pickValue_tSrc(y, x);
}</code></pre><h3><a class="docs_anchor_link__3W_rr" id="Appendbackendtooperation"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#Appendbackendtooperation"><img src="/static/images/anchor.svg"/></a>Append backend to operation</h3><p>You should use <code class="fill_light_grey docs_doc_code__1U1Vz">.GLSLKernel(kernel &lt;string&gt;)</code> for this.</p><pre data-component="highlight_code" class="language-js"><code class="language-js">import kernel from &#x27;./kernel.glsl&#x27;;

const myOperation = new gm.RegisterOperation(&#x27;MyOp&#x27;)
  .Input(&#x27;tSrc&#x27;, &#x27;uint8&#x27;)
  .Output(&#x27;uint8&#x27;)
  .SetShapeFn(() =&gt; [20, 15, 4])
  .Constant(&#x27;FILL&#x27;, 1.0)
  .Uniform(&#x27;uMultiplier&#x27;, &#x27;float&#x27;, 0.3)
  .LoadChunk(&#x27;pickValue&#x27;)
  .GLSLKernel(kernel)</code></pre><h2><a class="docs_anchor_link__3W_rr" id="Provideinputsandcompile"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#Provideinputsandcompile"><img src="/static/images/anchor.svg"/></a>Provide inputs and compile</h2><p>To prepare your operation for a run, you should compile it with providing input tensors:
<code class="fill_light_grey docs_doc_code__1U1Vz">.Compile(inputs &lt;Object&gt;)</code>, where inputs object has keys named same as operation&#x27;s input and contain tensor or operation as values</p><pre data-component="highlight_code" class="language-js"><code class="language-js">const tSrc = new gm.Tensor(&#x27;uint8&#x27;, [2, 2, 4]);

const myOperation = new gm.RegisterOperation(&#x27;MyOp&#x27;)
  .Input(&#x27;tSrc&#x27;, &#x27;uint8&#x27;)
  .Output(&#x27;uint8&#x27;)
  .SetShapeFn(() =&gt; [1, 1, 4])
  .Constant(&#x27;FILL&#x27;, 1.0)
  .Uniform(&#x27;uMultiplier&#x27;, &#x27;float&#x27;, 0.3)
  .LoadChunk(&#x27;pickValue&#x27;)
  .GLSLKernel(kernel)
  .Compile({ tSrc })</code></pre><p>This method returns <code class="fill_light_grey docs_doc_code__1U1Vz">Operation</code> instance that is ready to provide into <code class="fill_light_grey docs_doc_code__1U1Vz">Session</code>.</p><h2><a class="docs_anchor_link__3W_rr" id="Example"></a><a aria-hidden="true" aria-label="anchor" class="docs_anchor_link_style__3AIkg" href="/docs/create_operation#Example"><img src="/static/images/anchor.svg"/></a>Example</h2><p>index.js</p><pre data-component="highlight_code" class="language-js"><code class="language-js">import * as gm from &#x27;gammacv&#x27;;
import kernel from &#x27;./kernel.glsl&#x27;;

const tSrc = new gm.Tensor(&#x27;uint8&#x27;, [2, 2, 4], new Uint8Array([
  200, 2, 3, 34,  5, 6, 7, 125,
  9, 6, 7, 0,     3, 4, 5, 0,
]));

const myOperation = new gm.RegisterOperation(&#x27;MyOp&#x27;)
  .Input(&#x27;tSrc&#x27;, &#x27;uint8&#x27;)
  .Output(&#x27;uint8&#x27;)
  .SetShapeFn(() =&gt; [1, 1, 4])
  .Constant(&#x27;FILL&#x27;, 1.0)
  .Uniform(&#x27;uMultiplier&#x27;, &#x27;float&#x27;, 0.5)
  .LoadChunk(&#x27;pickValue&#x27;)
  .GLSLKernel(kernel)
  .Compile({ tSrc })</code></pre><p>kernel.glsl</p><pre data-component="highlight_code" class="language-glsl"><code class="language-glsl">// will be called just once since the output is only one pixel
// y and x will be 0.0
vec4 operation(float y, float x) {
  vec4 data = pickValue_tSrc(y, x);
  // data will have value around vec4(0.78, 0.0078, 0.011, 0.13)
  // since uint values are viewed as floats 0..1 that describes (0..255)

  return vec4(data.r * uMultiplier, FILL, FILL, FILL);
  // will return around vec4(0.78 * 0.5 = 0.39, 1.0, 1.0, 1.0)
  // that will be viewed in uint8 as vec4(100, 255, 255, 255).`
}</code></pre><p>Running this operation will output tensor with next data: [100, 255, 255, 255].</p></div></div><div class="footer_root__1HA-F" style="background-color:rgba(var(--white), 1);border-color:rgba(var(--light_grey), 1);border-width:1px 0px 0px 0px;border-style:solid"><p data-component="typography" class="break_word text_grey text_left b3">Made with ❤️ across the globe</p><div class="footer_spacer__qz-Ai"></div><p data-component="typography" class="break_word text_dark_grey text_left footer_version__vje18 b3">Api version<!-- -->: <!-- -->0.5.1</p><a href="mailto:info@peculiarventures.com" target="_blank" rel="noopener noreferrer" class="footer_nav_item__3mu9g text_grey b3">Get in touch</a></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"create_operation","data":"# Create Operation\n\nWhen building graphs using `GammaCV`, you may want to create a new `Operation`. This article will describe how to create your own `Operation`.\n\n## Prerequisites\nThis document assumes familiarity with the fundamentals of GammaCV introduced in the Core Concepts section of [Getting Started](/docs/get_started). We recommend completing Core Concepts before reading this tutorial.\n\n## Name operation\nTo create a shell your operation, you simply need to use `RegisterOperation`\n\n```js\nimport * as gm from 'gammacv';\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n```\n\n## Describe inputs and output\n### Inputs\nYou can append input using ```.Input(name \u003cstring\u003e, dtype \u003cstring\u003e)```\n\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('src', 'uint8')\n```\nThis code appends input named src and described it as unsigned byte datatype.\nAt this milestone, we support only `uint8` and `float32` input datatypes.\nEach `RegisterOperation` instance method returns itself, so you can pipe multiple inputs.\nIt is very usefull for future steps to name inputs starting with `t`, like \"src\" -\u003e \"tSrc\".\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Input('tMask', 'float32')\n```\n\n### Output\nYou should describe the output datatype using `.Output(dtype \u003cstring\u003e)`, and output shape using `.SetShapeFn(cb \u003cfunction\u003e)`.\nAt this milestone, we support only `uint8` and `float32` output datatypes and only shapes that matched `[n, m, 4]`.\nBy default output datatype and shape are the same as in first input.\nYou can specify Output just once for one operation.\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Input('tMask', 'float32')\n  .Output('uint8')\n  .SetShapeFn(() =\u003e [20, 15, 4])\n```\n\nIn this way, you described that your operation receives two inputs and specify their names and datatypes, and the output will be Tensor('uint8', [20, 15, 4]).\n\n## Describe variables and constants\nYou may want to have some variables or constants other than the input data.\n`.Constant(name \u003cstring\u003e, value \u003cstring|number\u003e)` - will create a constant that can't be change once operation was compiled.\n`.Uniform(name \u003cstring\u003e, type \u003cstring\u003e, value \u003cstring|number\u003e)` - will create a variable which you can change between operation executing, supported types are:\n```js\n'bool', 'int', 'uint',\n'float', 'double',\n'vec2', 'vec3', 'vec4',\n'mat2', 'mat3', 'mat4'\n```\n\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Input('tMask', 'float32')\n  .Output('uint8')\n  .SetShapeFn(() =\u003e [20, 15, 4])\n  .Constant('TRESHOLD', 0.5)\n  .Uniform('uMultiplier', 'float', 0.5)\n```\n\n## Write WebGL backend\nYou can write your WebGL backend as a string or as a separate file and load it via network request or your module bundler. This named as operation kernel.\n[WebGL](https://en.wikipedia.org/wiki/WebGL) backend should be written using [GLSL (OpenGL Shading Language)](https://en.wikipedia.org/wiki/OpenGL_Shading_Language). You should use [OpenGL ES 2.0](https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_2.0) standard to be compatible with devices that support only WebGL 1.0, and you can use [OpenGL ES 3.0](https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_3.0) for devices compatible with WebGL 2.0.\n\nYou shouldn't use `void main` in kernel code!\nThe entry point for your code is `vec4 operation(float y, float x)` that should be defined.\nThis entry point will be called for each output component of operation and receives coordinate of this component as float arguments and should return a 4-component vector of the output value.\n\n```glsl\nvec4 operation(float y, float x) {\n  return vec4(0.0);\n}\n```\nThis code will fill output with zeros.\n\n### Use constants and uniforms\nInside your glsl kernel you can use constants defined with RegisterOperation, just type the name of constant or variable, be careful and check the types of your variables.\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() =\u003e [20, 15, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n```\n```glsl\nvec4 operation(float y, float x) {\n  return vec4(y * uMultiplier, x * uMultiplier, TRESHOLD, TRESHOLD);\n}\n```\n\n### GLSL Chunks\nThe full documentation for GLSL Chunks, you can find [here](/docs/glsl_chunks)\nIf you want to get inputs data inside your kernel, you should use pre-defined glsl-chunks, and specify it's loading in RegisterOperation pipe:\n```js\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() =\u003e [20, 15, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n  .LoadChunk('pickValue')\n```\nThen you can use it in glsl code\n```glsl\nvec4 operation(float y, float x) {\n  return pickValue_tSrc(y, x) * pickValue_tSrc(y, x);\n}\n```\n\n### Append backend to operation\nYou should use `.GLSLKernel(kernel \u003cstring\u003e)` for this.\n```js\nimport kernel from './kernel.glsl';\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() =\u003e [20, 15, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel)\n```\n\n## Provide inputs and compile\nTo prepare your operation for a run, you should compile it with providing input tensors:\n`.Compile(inputs \u003cObject\u003e)`, where inputs object has keys named same as operation's input and contain tensor or operation as values\n\n```js\nconst tSrc = new gm.Tensor('uint8', [2, 2, 4]);\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() =\u003e [1, 1, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel)\n  .Compile({ tSrc })\n```\nThis method returns `Operation` instance that is ready to provide into `Session`.\n\n## Example\n\nindex.js\n```js\nimport * as gm from 'gammacv';\nimport kernel from './kernel.glsl';\n\nconst tSrc = new gm.Tensor('uint8', [2, 2, 4], new Uint8Array([\n  200, 2, 3, 34,  5, 6, 7, 125,\n  9, 6, 7, 0,     3, 4, 5, 0,\n]));\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() =\u003e [1, 1, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.5)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel)\n  .Compile({ tSrc })\n```\n\nkernel.glsl\n```glsl\n// will be called just once since the output is only one pixel\n// y and x will be 0.0\nvec4 operation(float y, float x) {\n  vec4 data = pickValue_tSrc(y, x);\n  // data will have value around vec4(0.78, 0.0078, 0.011, 0.13)\n  // since uint values are viewed as floats 0..1 that describes (0..255)\n\n  return vec4(data.r * uMultiplier, FILL, FILL, FILL);\n  // will return around vec4(0.78 * 0.5 = 0.39, 1.0, 1.0, 1.0)\n  // that will be viewed in uint8 as vec4(100, 255, 255, 255).`\n}\n```\n\nRunning this operation will output tensor with next data: [100, 255, 255, 255].\n"},"__N_SSG":true},"page":"/docs/[id]","query":{"id":"create_operation"},"buildId":"D6-BTCsGmFsmS3bk-HAyM","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/_next/static/chunks/webpack-7899de15d31abfcf2ba1.js" async=""></script><script src="/_next/static/chunks/framework-a254bdb28f684739f8fb.js" async=""></script><script src="/_next/static/chunks/commons-bd991d3914d6d42e2a9c.js" async=""></script><script src="/_next/static/chunks/433-cd3d6a81c7946c739a1f.js" async=""></script><script src="/_next/static/chunks/778-ca9322c2990db1f6c421.js" async=""></script><script src="/_next/static/chunks/main-5ec178cac14bcca48b45.js" async=""></script><script src="/_next/static/chunks/215-2125f971840a78b996f6.js" async=""></script><script src="/_next/static/chunks/pages/_app-23d28ef32fbe15e5719d.js" async=""></script><script src="/_next/static/chunks/422-4193e727ae41a09dbc80.js" async=""></script><script src="/_next/static/chunks/933-12f2e0948a4af74f41d8.js" async=""></script><script src="/_next/static/chunks/pages/docs/%5Bid%5D-139ef8803532d7f6f7b6.js" async=""></script><script src="/_next/static/D6-BTCsGmFsmS3bk-HAyM/_buildManifest.js" async=""></script><script src="/_next/static/D6-BTCsGmFsmS3bk-HAyM/_ssgManifest.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-115158166-2"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag() {
              dataLayer.push(arguments);
            }
            gtag('js', new Date());
            gtag('config', 'UA-115158166-2');
          </script><script>
            var _rollbarConfig = {
              accessToken: '2747c18861de445cb1f042ceaffb0a34',
              captureUncaught: true,
              captureUnhandledRejections: true,
              payload: {
                environment: 'production',
              },
            };
          </script><script async="" src="https://cdn.rollbar.com/rollbarjs/refs/tags/v2.21.0/rollbar.min.js"></script></body></html>
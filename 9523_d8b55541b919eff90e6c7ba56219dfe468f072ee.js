(self.webpackChunkapp=self.webpackChunkapp||[]).push([[9523],{9523:e=>{"use strict";e.exports=JSON.parse('[{"type":"heading","children":["Create Operation"],"depth":1},{"type":"paragraph","children":["When building graphs using ",{"type":"codespan","children":"GammaCV"},", you may want to create a new ",{"type":"codespan","children":"Operation"},". This article will describe how to create your own ",{"type":"codespan","children":"Operation"},"."]},{"type":"space","children":[]},{"type":"heading","children":["Prerequisites"],"depth":2},{"type":"paragraph","children":["This document assumes familiarity with the fundamentals of GammaCV introduced in the Core Concepts section of ",{"type":"link","href":"/docs/get_started","title":"/docs/get_started","children":["Getting Started"]},". We recommend completing Core Concepts before reading this tutorial."]},{"type":"space","children":[]},{"type":"heading","children":["Name operation"],"depth":2},{"type":"paragraph","children":["To create a shell your operation, you simply need to use ",{"type":"codespan","children":"RegisterOperation"}]},{"type":"space","children":[]},{"type":"code","children":"import * as gm from \'gammacv\';\\n\\nconst myOperation = new gm.RegisterOperation(\'MyOp\')","lang":"js"},{"type":"heading","children":["Describe inputs and output"],"depth":2},{"type":"heading","children":["Inputs"],"depth":3},{"type":"paragraph","children":["You can append input using ",{"type":"codespan","children":".Input(name <string>, dtype <string>)"}]},{"type":"space","children":[]},{"type":"code","children":"const myOperation = new gm.RegisterOperation(\'MyOp\')\\n  .Input(\'src\', \'uint8\')","lang":"js"},{"type":"paragraph","children":["This code appends input named src and described it as unsigned byte datatype.\\nAt this milestone, we support only ",{"type":"codespan","children":"uint8"}," and ",{"type":"codespan","children":"float32"}," input datatypes.\\nEach ",{"type":"codespan","children":"RegisterOperation"}," instance method returns itself, so you can pipe multiple inputs.\\nIt is very usefull for future steps to name inputs starting with ",{"type":"codespan","children":"t"},", like \\"src\\" -> \\"tSrc\\"."]},{"type":"code","children":"const myOperation = new gm.RegisterOperation(\'MyOp\')\\n  .Input(\'tSrc\', \'uint8\')\\n  .Input(\'tMask\', \'float32\')","lang":"js"},{"type":"heading","children":["Output"],"depth":3},{"type":"paragraph","children":["You should describe the output datatype using ",{"type":"codespan","children":".Output(dtype <string>)"},", and output shape using ",{"type":"codespan","children":".SetShapeFn(cb <function>)"},".\\nAt this milestone, we support only ",{"type":"codespan","children":"uint8"}," and ",{"type":"codespan","children":"float32"}," output datatypes and only shapes that matched ",{"type":"codespan","children":"[n, m, 4]"},".\\nBy default output datatype and shape are the same as in first input.\\nYou can specify Output just once for one operation."]},{"type":"code","children":"const myOperation = new gm.RegisterOperation(\'MyOp\')\\n  .Input(\'tSrc\', \'uint8\')\\n  .Input(\'tMask\', \'float32\')\\n  .Output(\'uint8\')\\n  .SetShapeFn(() => [20, 15, 4])","lang":"js"},{"type":"paragraph","children":["In this way, you described that your operation receives two inputs and specify their names and datatypes, and the output will be Tensor(\'uint8\', ","[","20, 15, 4])."]},{"type":"space","children":[]},{"type":"heading","children":["Describe variables and constants"],"depth":2},{"type":"paragraph","children":["You may want to have some variables or constants other than the input data.\\n",{"type":"codespan","children":".Constant(name <string>, value <string|number>)"}," - will create a constant that can\'t be change once operation was compiled.\\n",{"type":"codespan","children":".Uniform(name <string>, type <string>, value <string|number>)"}," - will create a variable which you can change between operation executing, supported types are:"]},{"type":"code","children":"\'bool\', \'int\', \'uint\',\\n\'float\', \'double\',\\n\'vec2\', \'vec3\', \'vec4\',\\n\'mat2\', \'mat3\', \'mat4\'","lang":"js"},{"type":"code","children":"const myOperation = new gm.RegisterOperation(\'MyOp\')\\n  .Input(\'tSrc\', \'uint8\')\\n  .Input(\'tMask\', \'float32\')\\n  .Output(\'uint8\')\\n  .SetShapeFn(() => [20, 15, 4])\\n  .Constant(\'TRESHOLD\', 0.5)\\n  .Uniform(\'uMultiplier\', \'float\', 0.5)","lang":"js"},{"type":"heading","children":["Write WebGL backend"],"depth":2},{"type":"paragraph","children":["You can write your WebGL backend as a string or as a separate file and load it via network request or your module bundler. This named as operation kernel.\\n",{"type":"link","href":"https://en.wikipedia.org/wiki/WebGL","title":"https://en.wikipedia.org/wiki/WebGL","children":["WebGL"]}," backend should be written using ",{"type":"link","href":"https://en.wikipedia.org/wiki/OpenGL_Shading_Language","title":"https://en.wikipedia.org/wiki/OpenGL_Shading_Language","children":["GLSL (OpenGL Shading Language)"]},". You should use ",{"type":"link","href":"https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_2.0","title":"https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_2.0","children":["OpenGL ES 2.0"]}," standard to be compatible with devices that support only WebGL 1.0, and you can use ",{"type":"link","href":"https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_3.0","title":"https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_3.0","children":["OpenGL ES 3.0"]}," for devices compatible with WebGL 2.0."]},{"type":"space","children":[]},{"type":"paragraph","children":["You shouldn\'t use ",{"type":"codespan","children":"void main"}," in kernel code","!\\nThe entry point for your code is ",{"type":"codespan","children":"vec4 operation(float y, float x)"}," that should be defined.\\nThis entry point will be called for each output component of operation and receives coordinate of this component as float arguments and should return a 4-component vector of the output value."]},{"type":"space","children":[]},{"type":"code","children":"vec4 operation(float y, float x) {\\n  return vec4(0.0);\\n}","lang":"glsl"},{"type":"paragraph","children":["This code will fill output with zeros."]},{"type":"space","children":[]},{"type":"heading","children":["Use constants and uniforms"],"depth":3},{"type":"paragraph","children":["Inside your glsl kernel you can use constants defined with RegisterOperation, just type the name of constant or variable, be careful and check the types of your variables."]},{"type":"code","children":"const myOperation = new gm.RegisterOperation(\'MyOp\')\\n  .Input(\'tSrc\', \'uint8\')\\n  .Output(\'uint8\')\\n  .SetShapeFn(() => [20, 15, 4])\\n  .Constant(\'FILL\', 1.0)\\n  .Uniform(\'uMultiplier\', \'float\', 0.3)","lang":"js"},{"type":"code","children":"vec4 operation(float y, float x) {\\n  return vec4(y * uMultiplier, x * uMultiplier, TRESHOLD, TRESHOLD);\\n}","lang":"glsl"},{"type":"heading","children":["GLSL Chunks"],"depth":3},{"type":"paragraph","children":["The full documentation for GLSL Chunks, you can find ",{"type":"link","href":"/docs/glsl_chunks","title":"/docs/glsl_chunks","children":["here"]},"\\nIf you want to get inputs data inside your kernel, you should use pre-defined glsl-chunks, and specify it\'s loading in RegisterOperation pipe:"]},{"type":"code","children":"const myOperation = new gm.RegisterOperation(\'MyOp\')\\n  .Input(\'tSrc\', \'uint8\')\\n  .Output(\'uint8\')\\n  .SetShapeFn(() => [20, 15, 4])\\n  .Constant(\'FILL\', 1.0)\\n  .Uniform(\'uMultiplier\', \'float\', 0.3)\\n  .LoadChunk(\'pickValue\')","lang":"js"},{"type":"paragraph","children":["Then you can use it in glsl code"]},{"type":"code","children":"vec4 operation(float y, float x) {\\n  return pickValue_tSrc(y, x) * pickValue_tSrc(y, x);\\n}","lang":"glsl"},{"type":"heading","children":["Append backend to operation"],"depth":3},{"type":"paragraph","children":["You should use ",{"type":"codespan","children":".GLSLKernel(kernel <string>)"}," for this."]},{"type":"code","children":"import kernel from \'./kernel.glsl\';\\n\\nconst myOperation = new gm.RegisterOperation(\'MyOp\')\\n  .Input(\'tSrc\', \'uint8\')\\n  .Output(\'uint8\')\\n  .SetShapeFn(() => [20, 15, 4])\\n  .Constant(\'FILL\', 1.0)\\n  .Uniform(\'uMultiplier\', \'float\', 0.3)\\n  .LoadChunk(\'pickValue\')\\n  .GLSLKernel(kernel)","lang":"js"},{"type":"heading","children":["Provide inputs and compile"],"depth":2},{"type":"paragraph","children":["To prepare your operation for a run, you should compile it with providing input tensors:\\n",{"type":"codespan","children":".Compile(inputs <Object>)"},", where inputs object has keys named same as operation\'s input and contain tensor or operation as values"]},{"type":"space","children":[]},{"type":"code","children":"const tSrc = new gm.Tensor(\'uint8\', [2, 2, 4]);\\n\\nconst myOperation = new gm.RegisterOperation(\'MyOp\')\\n  .Input(\'tSrc\', \'uint8\')\\n  .Output(\'uint8\')\\n  .SetShapeFn(() => [1, 1, 4])\\n  .Constant(\'FILL\', 1.0)\\n  .Uniform(\'uMultiplier\', \'float\', 0.3)\\n  .LoadChunk(\'pickValue\')\\n  .GLSLKernel(kernel)\\n  .Compile({ tSrc })","lang":"js"},{"type":"paragraph","children":["This method returns ",{"type":"codespan","children":"Operation"}," instance that is ready to provide into ",{"type":"codespan","children":"Session"},"."]},{"type":"space","children":[]},{"type":"heading","children":["Example"],"depth":2},{"type":"paragraph","children":["index.js"]},{"type":"code","children":"import * as gm from \'gammacv\';\\nimport kernel from \'./kernel.glsl\';\\n\\nconst tSrc = new gm.Tensor(\'uint8\', [2, 2, 4], new Uint8Array([\\n  200, 2, 3, 34,  5, 6, 7, 125,\\n  9, 6, 7, 0,     3, 4, 5, 0,\\n]));\\n\\nconst myOperation = new gm.RegisterOperation(\'MyOp\')\\n  .Input(\'tSrc\', \'uint8\')\\n  .Output(\'uint8\')\\n  .SetShapeFn(() => [1, 1, 4])\\n  .Constant(\'FILL\', 1.0)\\n  .Uniform(\'uMultiplier\', \'float\', 0.5)\\n  .LoadChunk(\'pickValue\')\\n  .GLSLKernel(kernel)\\n  .Compile({ tSrc })","lang":"js"},{"type":"paragraph","children":["kernel.glsl"]},{"type":"code","children":"// will be called just once since the output is only one pixel\\n// y and x will be 0.0\\nvec4 operation(float y, float x) {\\n  vec4 data = pickValue_tSrc(y, x);\\n  // data will have value around vec4(0.78, 0.0078, 0.011, 0.13)\\n  // since uint values are viewed as floats 0..1 that describes (0..255)\\n\\n  return vec4(data.r * uMultiplier, FILL, FILL, FILL);\\n  // will return around vec4(0.78 * 0.5 = 0.39, 1.0, 1.0, 1.0)\\n  // that will be viewed in uint8 as vec4(100, 255, 255, 255).`\\n}","lang":"glsl"},{"type":"paragraph","children":["Running this operation will output tensor with next data: ","[","100, 255, 255, 255]."]}]')}}]);
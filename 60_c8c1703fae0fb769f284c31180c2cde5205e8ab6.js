webpackJsonp([60],{484:function(e,n){e.exports=[{type:"heading",children:["Create Operation"],depth:1},{type:"paragraph",children:["When building graphs using ",{type:"codespan",children:"GammaCV"},", you may want to create a new ",{type:"codespan",children:"Operation"},". This article will describe how to create your own ",{type:"codespan",children:"Operation"},"."]},{type:"space",children:[]},{type:"heading",children:["Prerequisites"],depth:2},{type:"paragraph",children:["This document assumes familiarity with the fundamentals of GammaCV introduced in the Core Concepts section of ",{type:"link",href:"/docs/get_started",title:null,children:["Getting Started"]},". We recommend completing Core Concepts before reading this tutorial."]},{type:"space",children:[]},{type:"heading",children:["Name operation"],depth:2},{type:"paragraph",children:["To create a shell your operation, you simply need to use ",{type:"codespan",children:"RegisterOperation"}]},{type:"space",children:[]},{type:"code",children:"import * as gm from 'gammacv';\n\nconst myOperation = new gm.RegisterOperation('MyOp')",lang:"js"},{type:"heading",children:["Describe inputs and output"],depth:2},{type:"heading",children:["Inputs"],depth:3},{type:"paragraph",children:["You can append input using ",{type:"codespan",children:".Input(name <string>, dtype <string>)"}]},{type:"space",children:[]},{type:"code",children:"const myOperation = new gm.RegisterOperation('MyOp')\n  .Input('src', 'uint8')",lang:"js"},{type:"paragraph",children:["This code appends input named src and described it as unsigned byte datatype.\nAt this milestone, we support only ",{type:"codespan",children:"uint8"}," and ",{type:"codespan",children:"float32"}," input datatypes.\nEach ",{type:"codespan",children:"RegisterOperation"}," instance method returns itself, so you can pipe multiple inputs.\nIt is very usefull for future steps to name inputs starting with ",{type:"codespan",children:"t"},', like "src" -> "tSrc".']},{type:"code",children:"const myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Input('tMask', 'float32')",lang:"js"},{type:"heading",children:["Output"],depth:3},{type:"paragraph",children:["You should describe the output datatype using ",{type:"codespan",children:".Output(dtype <string>)"},", and output shape using ",{type:"codespan",children:".SetShapeFn(cb <function>)"},".\nAt this milestone, we support only ",{type:"codespan",children:"uint8"}," and ",{type:"codespan",children:"float32"}," output datatypes and only shapes that matched ",{type:"codespan",children:"[n, m, 4]"},".\nBy default output datatype and shape are the same as in first input.\nYou can specify Output just once for one operation."]},{type:"code",children:"const myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Input('tMask', 'float32')\n  .Output('uint8')\n  .SetShapeFn(() => [20, 15, 4])",lang:"js"},{type:"paragraph",children:["In this way, you described that your operation receives two inputs and specify their names and datatypes, and the output will be Tensor('uint8', ","[","20, 15, 4])."]},{type:"space",children:[]},{type:"heading",children:["Describe variables and constants"],depth:2},{type:"paragraph",children:["You may want to have some variables or constants other than the input data.\n",{type:"codespan",children:".Constant(name <string>, value <string|number>)"}," - will create a constant that can't be change once operation was compiled.\n",{type:"codespan",children:".Uniform(name <string>, type <string>, value <string|number>)"}," - will create a variable which you can change between operation executing, supported types are:"]},{type:"code",children:"'bool', 'int', 'uint',\n'float', 'double',\n'vec2', 'vec3', 'vec4',\n'mat2', 'mat3', 'mat4'",lang:"js"},{type:"code",children:"const myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Input('tMask', 'float32')\n  .Output('uint8')\n  .SetShapeFn(() => [20, 15, 4])\n  .Constant('TRESHOLD', 0.5)\n  .Uniform('uMultiplier', 'float', 0.5)",lang:"js"},{type:"heading",children:["Write WebGL backend"],depth:2},{type:"paragraph",children:["You can write your WebGL backend as a string or as a separate file and load it via network request or your module bundler. This named as operation kernel.\n",{type:"link",href:"https://en.wikipedia.org/wiki/WebGL",title:null,children:["WebGL"]}," backend should be written using ",{type:"link",href:"https://en.wikipedia.org/wiki/OpenGL_Shading_Language",title:null,children:["GLSL (OpenGL Shading Language)"]},". You should use ",{type:"link",href:"https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_2.0",title:null,children:["OpenGL ES 2.0"]}," standard to be compatible with devices that support only WebGL 1.0, and you can use ",{type:"link",href:"https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_3.0",title:null,children:["OpenGL ES 3.0"]}," for devices compatible with WebGL 2.0."]},{type:"space",children:[]},{type:"paragraph",children:["You shouldn't use ",{type:"codespan",children:"void main"}," in kernel code","!\nThe entry point for your code is ",{type:"codespan",children:"vec4 operation(float y, float x)"}," that should be defined.\nThis entry point will be called for each output component of operation and receives coordinate of this component as float arguments and should return a 4-component vector of the output value."]},{type:"space",children:[]},{type:"code",children:"vec4 operation(float y, float x) {\n  return vec4(0.0);\n}",lang:"glsl"},{type:"paragraph",children:["This code will fill output with zeros."]},{type:"space",children:[]},{type:"heading",children:["Use constants and uniforms"],depth:3},{type:"paragraph",children:["Inside your glsl kernel you can use constants defined with RegisterOperation, just type the name of constant or variable, be careful and check the types of your variables."]},{type:"code",children:"const myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() => [20, 15, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)",lang:"js"},{type:"code",children:"vec4 operation(float y, float x) {\n  return vec4(y * uMultiplier, x * uMultiplier, TRESHOLD, TRESHOLD);\n}",lang:"glsl"},{type:"heading",children:["GLSL Chunks"],depth:3},{type:"paragraph",children:["The full documentation for GLSL Chunks, you can find ",{type:"link",href:"/docs/glsl_chunks",title:null,children:["here"]},"\nIf you want to get inputs data inside your kernel, you should use pre-defined glsl-chunks, and specify it's loading in RegisterOperation pipe:"]},{type:"code",children:"const myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() => [20, 15, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n  .LoadChunk('pickValue')",lang:"js"},{type:"paragraph",children:["Then you can use it in glsl code"]},{type:"code",children:"vec4 operation(float y, float x) {\n  return pickValue_tSrc(y, x) * pickValue_tSrc(y, x);\n}",lang:"glsl"},{type:"heading",children:["Append backend to operation"],depth:3},{type:"paragraph",children:["You should use ",{type:"codespan",children:".GLSLKernel(kernel <string>)"}," for this."]},{type:"code",children:"import kernel from './kernel.glsl';\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() => [20, 15, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel)",lang:"js"},{type:"heading",children:["Provide inputs and compile"],depth:2},{type:"paragraph",children:["To prepare your operation for a run, you should compile it with providing input tensors:\n",{type:"codespan",children:".Compile(inputs <Object>)"},", where inputs object has keys named same as operation's input and contain tensor or operation as values"]},{type:"space",children:[]},{type:"code",children:"const tSrc = new gm.Tensor('uint8', [2, 2, 4]);\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() => [1, 1, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.3)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel)\n  .Compile({ tSrc })",lang:"js"},{type:"paragraph",children:["This method returns ",{type:"codespan",children:"Operation"}," instance that is ready to provide into ",{type:"codespan",children:"Session"},"."]},{type:"space",children:[]},{type:"heading",children:["Example"],depth:2},{type:"paragraph",children:["index.js"]},{type:"code",children:"import * as gm from 'gammacv';\nimport kernel from './kernel.glsl';\n\nconst tSrc = new gm.Tensor('uint8', [2, 2, 4], [\n  200, 2, 3, 34,  5, 6, 7, 125,\n  9, 6, 7, 0,     3, 4, 5, 0,\n]);\n\nconst myOperation = new gm.RegisterOperation('MyOp')\n  .Input('tSrc', 'uint8')\n  .Output('uint8')\n  .SetShapeFn(() => [1, 1, 4])\n  .Constant('FILL', 1.0)\n  .Uniform('uMultiplier', 'float', 0.5)\n  .LoadChunk('pickValue')\n  .GLSLKernel(kernel)\n  .Compile({ tSrc })",lang:"js"},{type:"paragraph",children:["kernel.glsl"]},{type:"code",children:"// will be called just once since the output is only one pixel\n// y and x will be 0.0\nvec4 operation(float y, float x) {\n  vec4 data = pickValue_tSrc(y, x);\n  // data will have value around vec4(0.78, 0.0078, 0.011, 0.13)\n  // since uint values are viewed as floats 0..1 that describes (0..255)\n\n  return vec4(data.r * uMultiplier, FILL, FILL, FILL);\n  // will return around vec4(0.78 * 0.5 = 0.39, 1.0, 1.0, 1.0)\n  // that will be viewed in uint8 as vec4(100, 255, 255, 255).`\n}",lang:"glsl"},{type:"paragraph",children:["Running this operation will output tensor with next data: ","[","100, 255, 255, 255]."]}]}});